<!
//  LightingModel.slh
//  fragment shader
//
//  Created by Sam Gateau on 1/25/14.
//  Copyright 2013 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
!>
<@if not LIGHTING_MODEL_SLH@>
<@def LIGHTING_MODEL_SLH@>

<@func declareLightingModel()@>

struct LightingModel {
    vec4 _UnlitShadedEmissiveLightmap;
    vec4 _ScatteringDiffuseSpecular;
    vec4 _AmbientDirectionalPointSpot;
    vec4 _ShowContour;
};

uniform lightingModelBuffer {
    LightingModel lightingModel;
};

float isUnlitEnabled() {
    return lightingModel._UnlitShadedEmissiveLightmap.x;
}
float isShadedEnabled() {
    return lightingModel._UnlitShadedEmissiveLightmap.y;
}
float isEmissiveEnabled() {
    return lightingModel._UnlitShadedEmissiveLightmap.z;
}
float isLightmapEnabled() {
    return lightingModel._UnlitShadedEmissiveLightmap.w;
}

float isScatteringEnabled() {
    return lightingModel._ScatteringDiffuseSpecular.x;
}
float isDiffuseEnabled() {
    return lightingModel._ScatteringDiffuseSpecular.y;
}
float isSpecularEnabled() {
    return lightingModel._ScatteringDiffuseSpecular.z;
}

float isAmbientEnabled() {
    return lightingModel._AmbientDirectionalPointSpot.x;
}
float isDirectionalEnabled() {
    return lightingModel._AmbientDirectionalPointSpot.y;
}
float isPointEnabled() {
    return lightingModel._AmbientDirectionalPointSpot.z;
}
float isSpotEnabled() {
    return lightingModel._AmbientDirectionalPointSpot.w;
}

float isShowContour() {
    return lightingModel._ShowContour.x;
}

<@endfunc@>



<@func declareEvalPBRShading()@>

vec3 fresnelSchlick(vec3 fresnelColor, vec3 lightDir, vec3 halfDir) {
    return fresnelColor + (1.0 - fresnelColor) * pow(1.0 - clamp(dot(lightDir, halfDir), 0.0, 1.0), 5);
}

float specularDistribution(float roughness, vec3 normal, vec3 halfDir) {
    float ndoth = clamp(dot(halfDir, normal), 0.0, 1.0);
    float gloss2 = pow(0.001 + roughness, 4);
    float denom = (ndoth * ndoth*(gloss2 - 1) + 1);
    float power = gloss2 / (3.14159 * denom * denom);
    return power;
}
<! //NOTE: ANother implementation for specularDistribution
    float specularDistribution(float roughness, vec3 normal, vec3 halfDir) {
    float gloss = exp2(10 * (1.0 - roughness) + 1);
    float power = pow(clamp(dot(halfDir, normal), 0.0, 1.0), gloss);
    power *= (gloss * 0.125 + 0.25);
    return power;
}
!>
// Frag Shading returns the diffuse amount as W and the specular rgb as xyz
vec4 evalPBRShading(vec3 fragNormal, vec3 fragLightDir, vec3 fragEyeDir, float metallic, vec3 fresnel, float roughness) {
    // Diffuse Lighting
    float diffuse = clamp(dot(fragNormal, fragLightDir), 0.0, 1.0);

    // Specular Lighting
    vec3 halfDir = normalize(fragEyeDir + fragLightDir);
    vec3 fresnelColor = fresnelSchlick(fresnel, fragLightDir, halfDir);
    float power = specularDistribution(roughness, fragNormal, halfDir);
    vec3 specular = power * fresnelColor * diffuse;

    return vec4(specular, (1.0 - metallic) * diffuse * (1 - fresnelColor.x));
}
<@endfunc@>

<$declareEvalPBRShading()$>

// Return xyz the specular/reflection component and w the diffuse component
vec4 evalFragShading(vec3 fragNormal, vec3 fragLightDir, vec3 fragEyeDir, float metallic, vec3 specular, float roughness) {
    return evalPBRShading(fragNormal, fragLightDir, fragEyeDir, metallic, specular, roughness);
}
<!
uniform sampler2D scatteringSpecularBeckmann;

float fetchSpecularBeckmann(float ndoth, float roughness) {
    return pow(2.0 * texture(scatteringSpecularBeckmann, vec2(ndoth, roughness)).r, 10.0);
}

float fresnelReflectance(vec3 H, vec3 V, float Fo) {
    float base = 1.0 - dot(V, H);
    float exponential = pow(base, 5.0);
    return exponential + Fo * (1.0 - exponential);
}

float skinSpecular(vec3 N, vec3 L, vec3 V, float roughness, float intensity) {
    float result = 0.0;
    float ndotl = dot(N, L);
    if (ndotl > 0.0) {
        vec3 h = L + V;
        vec3 H = normalize(h);
        float ndoth = dot(N, H);
        float PH = fetchSpecularBeckmann(ndoth, roughness);
        float F = fresnelReflectance(H, V, 0.028);
        float frSpec = max(PH * F / dot(h, h), 0.0);
        result = ndotl * intensity * frSpec;
    }

    return result;
}

// Eval shading
vec3 brdf = evalSkinBRDF(fragLightDir, normal, midNormal, lowNormal, curvature);
float scatteringLevel = getScatteringLevel();
vec4 shading;
float standardDiffuse = clamp(dot(normal, fragLightDir), 0.0, 1.0);
{ // Key Sun Lighting
    // Diffuse Lighting
    //float diffuse = clamp(dot(normal, fragLightDir), 0.0, 1.0);

    // Specular Lighting
    vec3 halfDir = normalize(fragEyeDir + fragLightDir);

    float specular = skinSpecular(normal, fragLightDir, fragEyeDir, roughness, 1.0);

    vec3 fresnelColor = fresnelSchlick(fresnel, fragLightDir, halfDir);
    float power = specularDistribution(roughness, normal, halfDir);
    //vec3 specular = power * fresnelColor * standardDiffuse;

    shading = vec4(vec3(specular), (1 - fresnelColor.x));
}


if (scatteringLevel < 0.1) {
    brdf = vec3(standardDiffuse);
}
brdf = mix(vec3(standardDiffuse), brdf, scatteringLevel * scattering);


diffuse = albedo * brdf.xyz * lightEnergy;

specular = shading.rgb * lightEnergy;

!>

<@endif@>
