<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  Created by Sam Gateau on 6/8/16.
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//


const float _PI = 3.14159265358979523846;


uniform sampler2D profileMap;
/*
vec3 scatter(float r) {
    return texture(profileMap, vec2(2.0 * r, 0.5)).xyz;
}
*/

float gaussian(float v, float r) {
    return (1.0 / sqrt(2.0 * _PI * v)) * exp(-(r*r) / (2.0 * v));
}

vec3 scatter(float r) {
    // Values from GPU Gems 3 "Advanced Skin Rendering".
    // Originally taken from real life samples.
    vec4 profile[6] = vec4[6](
        vec4(0.0064, 0.233, 0.455, 0.649),
        vec4(0.0484, 0.100, 0.336, 0.344),
        vec4(0.1870, 0.118, 0.198, 0.000),
        vec4(0.5670, 0.113, 0.007, 0.007),
        vec4(1.9900, 0.358, 0.004, 0.000),
        vec4(7.4100, 0.078, 0.000, 0.000)
        );
    //const int profileNum = 6;




    vec3 ret(0.0);
    for (int i = 0; i < 6; i++) {
        float v = profile[i].x * 1.414;
        float g = gaussian(v, r);
        ret += g * profile[i].yzw;
    }

    return ret;
}


vec3 integrate(float cosTheta, float skinRadius) {
   // Angle from lighting direction.
   float theta = acos(cosTheta);
   vec3 totalWeights = vec3(0.0);
   vec3 totalLight= vec3(0.0);
   
   float a = -(_PI);
   
   float inc = 0.1;
   
   while (a <= (_PI)) {
       float sampleAngle = theta + a;
       float diffuse = clamp(cos(sampleAngle), 0.0, 1.0);
        //if (diffuse < 0.0) diffuse = 0.0;
        //if (diffuse > 1.0) diffuse = 1.0;

       // Distance.
       float sampleDist = abs(2.0 * skinRadius * sin(a * 0.5));
       
       // Profile Weight.
       vec3 weights = scatter( sampleDist);
       
       totalWeights += weights;
       totalLight += diffuse * weights;
       a += inc;
   }
   
   vec3 result = (totalLight / totalWeights);
   return clamp(result, vec3(0.0), vec3(1.0));

   return min(sqrt(result), vec3(1.0));

   return scatter(skinRadius);
}

in vec2 varTexCoord0;
out vec4 outFragColor;

void main(void) {

    // Lookup by: x: NDotL y: 1 / r
    //float y = 2.0 * 1.0 / ((j + 1.0) / (double)height);
    //float x = ((i / (double)width) * 2.0) - 1.0;

    outFragColor = vec4(integrate(varTexCoord0.x * 2.0 - 1.0, 2.0 / varTexCoord0.y), 1.0);
}

