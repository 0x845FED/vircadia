<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  Created by Sam Gateau on 6/8/16.
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//


<@include DeferredTransform.slh@>
<$declareDeferredFrameTransform()$>


<@include DeferredGlobalLight.slh@>

<$declareEvalGlobalSpecularIrradiance(0, 1, 0)$>

uniform sampler2D linearDepthMap;
float getZEye(ivec2 pixel) {
    return -texelFetch(linearDepthMap, pixel, 0).x;
}
float getZEyeLinear(vec2 texcoord) {
    return -texture(linearDepthMap, texcoord).x;
}

<@include DeferredBufferRead.slh@>

vec2 sideToFrameTexcoord(vec2 side, vec2 texcoordPos) {
    return vec2((texcoordPos.x + side.x) * side.y, texcoordPos.y);
}

// the curvature texture
uniform sampler2D curvatureMap;

vec4 fetchCurvature(vec2 texcoord) {
    return texture(curvatureMap, texcoord);
}

// the curvature texture
uniform sampler2D diffusedCurvatureMap;

vec4 fetchDiffusedCurvature(vec2 texcoord) {
    return texture(diffusedCurvatureMap, texcoord);
}


uniform sampler2D scatteringLUT;

vec3 fetchBRDF(float LdotN, float curvature) {
    return texture(scatteringLUT, vec2( LdotN * 0.5 + 0.5, curvature)).xyz;
}

vec3 fetchBRDFSpectrum(vec3 LdotNSpectrum, float curvature) {
    return vec3(
        fetchBRDF(LdotNSpectrum.r, curvature).r,
        fetchBRDF(LdotNSpectrum.g, curvature).g,
        fetchBRDF(LdotNSpectrum.b, curvature).b
    );
}

// Scattering parameters

struct ScatteringParameters {
    vec4 normalBendInfo; // R, G, B, factor
    vec4 curvatureInfo;// Offset, Scale
};

uniform scatteringParamsBuffer {
    ScatteringParameters parameters;
};

vec3 getBendFactor() {
    return parameters.normalBendInfo.xyz * parameters.normalBendInfo.w;
}

float unpackCurvature(float packedCurvature) {
    return abs(packedCurvature * 2 - 1) * 0.5f * parameters.curvatureInfo.y + parameters.curvatureInfo.x;
}


in vec2 varTexCoord0;
out vec4 _fragColor;

//uniform vec3 uniformLightVector = vec3(1.0);

void main(void) {

    DeferredFragment fragment = unpackDeferredFragmentNoPosition(varTexCoord0);

    vec3 normal = fragment.normal; // .getWorldNormal(varTexCoord0);
    vec4 blurredCurvature = fetchCurvature(varTexCoord0);
    vec4 diffusedCurvature = fetchDiffusedCurvature(varTexCoord0);

    // --> Get curvature data
    vec3 bentNormalHigh = normalize( (blurredCurvature.xyz - 0.5f) * 2.0f );
    vec3 bentNormalLow = normalize( (diffusedCurvature.xyz - 0.5f) * 2.0f );
    float curvature = unpackCurvature(diffusedCurvature.w);


 //   _fragColor = vec4(vec3(diffusedCurvature.xyz), 1.0);

       // --> Calculate the light vector.
       
    Light light = getLight();
    vec3 fragLightDir = -getLightDirection(light); //normalize(uniformLightVector); //normalize(lightPos - sourcePos.xyz);
    
   // _fragColor = vec4(fetchBRDF(dot(bentNormalR, fragLightDir), abs(diffusedCurvature.w * 2 - 1)), 1.0);
   //  _fragColor = vec4(vec3(abs(dot(bentNormalR, fragLightDir))), 1.0);
 //    _fragColor = vec4(vec3(varTexCoord0, 0.0), 1.0);
  //  _fragColor = vec4(vec3(bentNormalR * 0.5 + 0.5), 1.0);


    vec3 rS = bentNormalHigh;
    
    vec3 bendFactorSpectrum = getBendFactor();
    vec3 rN = normalize(mix(normal, bentNormalLow, bendFactorSpectrum.x));
    vec3 gN = normalize(mix(bentNormalHigh, bentNormalLow, bendFactorSpectrum.y));
    vec3 bN = normalize(mix(bentNormalHigh, bentNormalLow, bendFactorSpectrum.z));

    vec3 NdotLSpectrum  = vec3(dot(rN, fragLightDir), dot(gN, fragLightDir), dot(bN, fragLightDir));

    // --> Look up the pre-integrated curvature-dependent BDRF textures
    vec3 bdrf = fetchBRDFSpectrum(NdotLSpectrum, curvature);


    // Pixel being shaded
    ivec2 pixelPos;
    vec2 texcoordPos;
    ivec4 stereoSide;
    ivec2 framePixelPos = getPixelPosTexcoordPosAndSide(gl_FragCoord.xy, pixelPos, texcoordPos, stereoSide);
    vec2 stereoSideClip = vec2(stereoSide.x, (isStereo() ? 0.5 : 1.0));
    vec2 frameTexcoordPos = sideToFrameTexcoord(stereoSideClip, texcoordPos);

    // Fetch the z under the pixel (stereo or not)
    float Zeye = getZEye(framePixelPos);

    vec3 worldNormal = fragment.normal;

    // The position of the pixel fragment in Eye space then in world space
    vec3 eyePos = evalEyePositionFromZeye(stereoSide.x, Zeye, texcoordPos);
    vec3 fragEyeDir = -(frameTransform._viewInverse * vec4(normalize(eyePos), 0.0)).xyz;
    vec3 fresnel = vec3(0.03); // Default Di-electric fresnel value
    if (fragment.metallic > 0.5) {
        fresnel = fragment.diffuse;
        fragment.metallic = 1.0;
    }
    vec3 albedo = fragment.diffuse;
    vec3 fragNormal = fragment.normal;

    vec4 shading;

    { // Key Sun Lighting
        // Diffuse Lighting
        float diffuse = clamp(dot(fragNormal, fragLightDir), 0.0, 1.0);
    
        // Specular Lighting
        vec3 halfDir = normalize(fragEyeDir + fragLightDir);
        vec3 fresnelColor = fresnelSchlick(fresnel, fragLightDir,halfDir);
        float power = specularDistribution(fragment.roughness, fragNormal, halfDir);
        vec3 specular = power * fresnelColor * diffuse;

        shading = vec4(specular, (1.0 - fragment.metallic) * diffuse * (1 - fresnelColor.x));
    }

    vec3 color = vec3(albedo * vec3(bdrf.xyz) + shading.rgb) * getLightColor(light) * getLightIntensity(light);


    // Diffuse from ambient
    color += (1 - fragment.metallic) * albedo * evalSphericalLight(getLightAmbientSphere(light), bentNormalHigh).xyz * 1.0 * getLightAmbientIntensity(light);

    // Specular highlight from ambient
    vec3 specularLighting = evalGlobalSpecularIrradiance(light, fragEyeDir, fragNormal, fragment.roughness, fresnel, 1.0);
    color += specularLighting;

    //_fragColor = vec4(evalSkyboxLight(rS, 0.0).rgb, 1.0);

    _fragColor = vec4(color, 1.0);
}


