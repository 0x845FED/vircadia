<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  drawItemBounds.slv
//  vertex shader
//
//  Created by Sam Gateau on 6/29/2015.
//  Copyright 2015 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include gpu/Transform.slh@>
<$declareStandardTransform()$>

<@include gpu/Color.slh@>
<$declareColorWheel()$>

uniform vec4 inColor;


struct WorkloadView {
    vec4 direction_far;
    vec4 fov;
    vec4 origin;
    vec4 regions[3];
};

#if defined(GPU_GL410)
uniform samplerBuffer workloadViewsBuffer;
WorkloadView getWorkloadView(int i) {
    int offset = 2 * i;
    WorkloadView view;
    view.origin = texelFetch(workloadViewsBuffer, offset);
    view.radiuses = texelFetch(workloadViewsBuffer, offset + 1);
    return view;
}
#else
layout(std140) buffer workloadViewsBuffer {
    WorkloadView _views[];
};
WorkloadView getWorkloadView(int i) {
    WorkloadView view = _views[i];
    return view;
}
#endif



out vec4 varColor;
out vec3 varTexcoord;

const int NUM_VERTICES_PER_VIEW = 27;
const int NUM_REGIONS_PER_VIEW = 3;
const int NUM_VERTICES_PER_VIEW_REGION = NUM_VERTICES_PER_VIEW / NUM_REGIONS_PER_VIEW;

void main(void) {
    const vec4 UNIT_SPRITE[NUM_VERTICES_PER_VIEW_REGION] = vec4[NUM_VERTICES_PER_VIEW_REGION](
        vec4(-1.0, -1.0, 0.0, 1.0),
        vec4(3.0, -1.0, 0.0, 1.0),
        vec4(-1.0, 3.0, 0.0, 1.0),

        vec4(-1.0, 0.0, -1.0, 1.0),
        vec4(3.0, 0.0, -1.0, 1.0),
        vec4(-1.0, 0.0, 3.0, 1.0),

        vec4(0.0, -1.0, -1.0, 1.0),
        vec4(0.0, 3.0, -1.0, 1.0),
        vec4(0.0, -1.0, 3.0, 1.0)
    );
     const int UNIT_SPRITE_INDICES[NUM_VERTICES_PER_VIEW_REGION] = int[NUM_VERTICES_PER_VIEW_REGION](
        0, 1, 2, 3, 4, 5, 6, 7, 8
    );

    int viewID = gl_VertexID / NUM_VERTICES_PER_VIEW;
    int viewVertexID = gl_VertexID - viewID * NUM_VERTICES_PER_VIEW;

    int regionID = viewVertexID / NUM_VERTICES_PER_VIEW_REGION;
    int regionVertexID = viewVertexID - regionID * NUM_VERTICES_PER_VIEW_REGION;

    int vertexID = regionVertexID;

    vec4 spriteVert = UNIT_SPRITE[UNIT_SPRITE_INDICES[vertexID]];

    WorkloadView view = getWorkloadView(viewID);

    vec4 region = view.regions[regionID];

    vec4 proxyPosWorld = vec4(region.xyz, 1.0);

    // standard transform, bring proxy in view space
    TransformCamera cam = getTransformCamera();
    TransformObject obj = getTransformObject();
    vec4 proxyPosEye;
    <$transformModelToEyePos(cam, obj, proxyPosWorld, proxyPosEye)$>

    // Define the billboarded space
    vec3 dirZ = vec3(0.0, 0.0, 1.0);
    vec3 dirX = vec3(1.0, 0.0, 0.0);
    vec3 dirY = vec3(0.0, 1.0, 0.0);

    /*normalize(cross(vec3(0.0, 1.0, 0.0), dirZ));
    if (dot(proxyPosEye.xyz, proxyPosEye.xyz) > 0.01) {
        dirZ = -normalize(proxyPosEye.xyz);
    }
    vec3 dirX = normalize(cross(vec3(0.0, 1.0, 0.0), dirZ));
    vec3 dirY = normalize(cross(dirZ, dirX));
    */
   float regionRadius = region.w;

    vec3 originSpaceVert =  dirY * (-0.02) + regionRadius * ( dirX * spriteVert.x + dirY * spriteVert.y + dirZ * spriteVert.z);

    vec4 pos = vec4(proxyPosEye.xyz + originSpaceVert, 1.0);
    varTexcoord = spriteVert.xyz;
    <$transformEyeToClipPos(cam, pos, gl_Position)$>

    // Convert region to color
    varColor = vec4(colorWheel(float(regionID) / 4.0), regionRadius);
}
