<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  drawItemBounds.slv
//  vertex shader
//
//  Created by Sam Gateau on 6/29/2015.
//  Copyright 2015 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include gpu/Transform.slh@>
<$declareStandardTransform()$>

<@include gpu/Color.slh@>
<$declareColorWheel()$>

uniform vec4 inColor;


struct WorkloadView {
    vec4 origin;
    vec4 radiuses;
};

#if defined(GPU_GL410)
uniform samplerBuffer workloadViewsBuffer;
WorkloadView getWorkloadView(int i) {
    int offset = 2 * i;
    WorkloadView view;
    view.origin = texelFetch(workloadViewsBuffer, offset);
    view.radiuses = texelFetch(workloadViewsBuffer, offset + 1);
    return view;
}
#else
layout(std140) buffer workloadViewsBuffer {
    WorkloadView _views[];
};
WorkloadView getWorkloadView(int i) {
    WorkloadView view = _views[i];
    return view;
}
#endif



out vec4 varColor;
out vec2 varTexcoord;

void main(void) {
    const vec4 UNIT_SPRITE[3] = vec4[3](
        vec4(-1.0, -1.0, 0.0, 1.0),
        vec4(3.0, -1.0, 0.0, 1.0),
        vec4(-1.0, 3.0, 0.0, 1.0)
    );
     const int UNIT_SPRITE_INDICES[3] = int[3](
        0, 1, 2
    );

    int viewID = gl_VertexID / 9;
    int reminder = gl_VertexID - viewID * 9;
    int regionID = reminder / 3;
    reminder = reminder - regionID * 3;
    int vertexID = reminder;

    vec4 spriteVert = UNIT_SPRITE[UNIT_SPRITE_INDICES[vertexID]];

    WorkloadView view = getWorkloadView(viewID);
    vec4 proxyPosWorld = vec4(view.origin.xyz, 1.0);

    // standard transform, bring proxy in view space
    TransformCamera cam = getTransformCamera();
    TransformObject obj = getTransformObject();
    vec4 proxyPosEye;
    <$transformModelToEyePos(cam, obj, proxyPosWorld, proxyPosEye)$>

    // Define the billboarded space
    vec3 dirZ = -normalize(proxyPosEye.xyz);
    vec3 dirX = normalize(cross(vec3(0.0, 1.0, 0.0), dirZ));
    vec3 dirY = vec3(0.0, 1.0, 0.0);
   // vec3 dirY = normalize(cross(dirZ, vec3(1.0, 0.0, 0.0)));

   float regionRadius = view.radiuses[regionID];

    vec4 pos = vec4(proxyPosEye.xyz + regionRadius * ( dirX * spriteVert.x + dirY * spriteVert.y /* + dirZ * spriteVert.z*/), 1.0);
    varTexcoord = spriteVert.xy;
    <$transformEyeToClipPos(cam, pos, gl_Position)$>

    // Convert region to color
    varColor = vec4(colorWheel(float(regionID) / 4.0), regionRadius);
}
