//
//  Created by Sam Gondelman on 9/13/2018
//  Copyright 2018 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//
<@if not BLENDSHAPE_SLH@>
<@def BLENDSHAPE_SLH@>

<@func declareBlendshape(USE_NORMAL, USE_TANGENT)@>

struct PackedBlendshapeOffset {
    uvec4 packedPosNorTan;
};

struct BlendshapeOffset {
    vec3 position;
<@if USE_NORMAL@>
    vec3 normal;
<@endif@>
<@if USE_TANGENT@>
    vec3 tangent;
<@endif@>
};

const float oneOver511 = 1.0 / 511.0;

vec3 unpackSnorm3x10_1x2(int packed) {  
    vec4 _unpacked = vec4(
           clamp( float( bitfieldExtract(packed, 0, 10)) * oneOver511, -1.0, 1.0),
           clamp( float( bitfieldExtract(packed, 10, 10)) * oneOver511, -1.0, 1.0),
           clamp( float( bitfieldExtract(packed, 20, 10)) * oneOver511, -1.0, 1.0),
           0.0
        );
    return _unpacked.xyz;
}

#if defined(GPU_GL410)
layout(binding=0) uniform samplerBuffer blendshapeOffsetsBuffer;

vec2 gpu_unpackHalf2x16(uint packed) {  
    return unpackHalf2x16(packed);
}

BlendshapeOffset getBlendshapeOffset(int i) {
    vec4 fetched = texelFetch(blendshapeOffsetsBuffer, i);
    uvec4 elem_packed = uvec4(floatBitsToUint(fetched.x), floatBitsToUint(fetched.y), floatBitsToUint(fetched.z), floatBitsToUint(fetched.w));

    BlendshapeOffset unpacked;
    unpacked.position = vec3(gpu_unpackHalf2x16((elem_packed.x)), gpu_unpackHalf2x16(uint(elem_packed.y)).x);
<@if USE_NORMAL@>
    unpacked.normal = unpackSnorm3x10_1x2(int(elem_packed.z)).xyz;
<@endif@>
<@if USE_TANGENT@>
    unpacked.tangent = unpackSnorm3x10_1x2(int(elem_packed.w)).xyz;
<@endif@>

    return unpacked;
}
#else
layout(std140, binding=0) buffer blendshapeOffsetsBuffer {
    uvec4 _packedBlendshapeOffsets[];
};
BlendshapeOffset getBlendshapeOffset(int i) {

    uvec4 elem_packed = _packedBlendshapeOffsets[i];

    BlendshapeOffset unpacked;
    unpacked.position = vec3(unpackHalf2x16((elem_packed.x)), unpackHalf2x16(uint(elem_packed.y)).x);
<@if USE_NORMAL@>
    unpacked.normal = unpackSnorm3x10_1x2(int(elem_packed.z)).xyz;
<@endif@>
<@if USE_TANGENT@>
    unpacked.tangent = unpackSnorm3x10_1x2(int(elem_packed.w)).xyz;
<@endif@>

    return unpacked;
}
#endif

void evalBlendshape(int i, vec4 inPosition, out vec4 position
<@if USE_NORMAL@>
                           , vec3 inNormal, out vec3 normal
<@endif@>
<@if USE_TANGENT@>
                           , vec3 inTangent, out vec3 tangent
<@endif@>
) {
    BlendshapeOffset blendshapeOffset = getBlendshapeOffset(i);
    position = inPosition + vec4(blendshapeOffset.position, 0.0);
<@if USE_NORMAL@>
    normal = normalize(inNormal + blendshapeOffset.normal.xyz);
<@endif@>
<@if USE_TANGENT@>
    tangent = normalize(inTangent + blendshapeOffset.tangent.xyz);
<@endif@>
}

<@endfunc@>

<@endif@> // if not BLENDSHAPE_SLH
