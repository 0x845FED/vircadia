//
//  Created by Sam Gondelman on 9/13/2018
//  Copyright 2018 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//
<@if not BLENDSHAPE_SLH@>
<@def BLENDSHAPE_SLH@>

<@func declareBlendshape(USE_NORMAL, USE_TANGENT)@>

struct PackedBlendshapeOffset {
    uvec4 packedPosNorTan;
};

struct BlendshapeOffset {
    vec3 position;
<@if USE_NORMAL@>
    vec3 normal;
<@endif@>
<@if USE_TANGENT@>
    vec3 tangent;
<@endif@>
};

const float oneOver511 = 1.0 / 511.0;

vec3 unpackSnorm3x10_1x2(int packedX10Y10Z10A2) {  
    vec4 my_unpacked = vec4(
           clamp( float( (packedX10Y10Z10A2 & 0x000003FF) - 511 ) / 511.0, -1.0, 1.0),
           clamp( float( ((packedX10Y10Z10A2 >> 10) & 0x000003FF) - 511 ) / 511.0, -1.0, 1.0),
           clamp( float( ((packedX10Y10Z10A2 >> 20) & 0x000003FF) - 511 ) / 511.0, -1.0, 1.0),
           0.0//clamp( float( int((packedX10Y10Z10A2 >> 30) & 0x00000003) - 1 ), -1.0, 1.0)
        );
    return my_unpacked.xyz;
}

#if defined(GPU_GL410)
layout(binding=0) uniform samplerBuffer blendshapeOffsetsBuffer;
BlendshapeOffset getBlendshapeOffset(int i) {
    int offset = 3 * i;
    BlendshapeOffset blendshapeOffset;
    blendshapeOffset.position = texelFetch(blendshapeOffsetsBuffer, offset);
<@if USE_NORMAL@>
    blendshapeOffset.normal = texelFetch(blendshapeOffsetsBuffer, offset + 1);
<@endif@>
<@if USE_TANGENT@>
    blendshapeOffset.tangent = texelFetch(blendshapeOffsetsBuffer, offset + 2);
<@endif@>
    return blendshapeOffset;
}
#else
layout(std140, binding=0) buffer blendshapeOffsetsBuffer {
    ivec4 _packedBlendshapeOffsets[];
};
BlendshapeOffset getBlendshapeOffset(int i) {

    ivec4 elem_packed = _packedBlendshapeOffsets[i];

    BlendshapeOffset unpacked;
    vec2 pZnZ = unpackHalf2x16(uint(elem_packed.y));
    unpacked.position = vec3(unpackHalf2x16(uint(elem_packed.x)), pZnZ.x);
<@if USE_NORMAL@>
    unpacked.normal = vec3(unpackHalf2x16(uint(elem_packed.z)), pZnZ.y);
    //unpacked.normal = unpackSnorm3x10_1x2((elem_packed.z)).xyz;
<@endif@>
<@if USE_TANGENT@>
    unpacked.tangent = unpackSnorm3x10_1x2((elem_packed.w)).xyz;
<@endif@>

    return unpacked;
}
#endif

void evalBlendshape(int i, vec4 inPosition, out vec4 position
<@if USE_NORMAL@>
                           , vec3 inNormal, out vec3 normal
<@endif@>
<@if USE_TANGENT@>
                           , vec3 inTangent, out vec3 tangent
<@endif@>
) {
    BlendshapeOffset blendshapeOffset = getBlendshapeOffset(i);
    position = inPosition + vec4(blendshapeOffset.position, 0.0);
<@if USE_NORMAL@>
    normal = normalize(inNormal + blendshapeOffset.normal.xyz);
<@endif@>
<@if USE_TANGENT@>
    tangent = normalize(inTangent /*+ blendshapeOffset.tangent.xyz*/);
<@endif@>
}

<@endfunc@>

<@endif@> // if not BLENDSHAPE_SLH
