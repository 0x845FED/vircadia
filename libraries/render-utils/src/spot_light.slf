<@include Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  spot_light.frag
//  fragment shader
//
//  Created by Andrzej Kapolka on 9/18/14.
//  Copyright 2014 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

// Everything about deferred buffer
<@include DeferredBuffer.slh@>

// Everything about light
<@include Light.slh@>

// The view Matrix
uniform mat4 invViewMat;

void main(void) {
    // get the depth and exit early if it doesn't pass the test
    vec2 texCoord = gl_TexCoord[0].st / gl_TexCoord[0].q;

    DeferredFragment frag = unpackDeferredFragment(texCoord);
      
    // Kill if in front of the light volume
    float depth = frag.depthVal;
    if (depth < gl_FragCoord.z) {
        discard;
    }

    // Need the light now
    Light light = getLight();

    // Make the Light vector going from fragment to light center in world space
    vec4 wPos = invViewMat * frag.position;
    vec3 fragLightVec = getLightPosition(light) - wPos.xyz;

    // Kill if too far from the light center
    if (dot(fragLightVec, fragLightVec) > getLightSquareRadius(light)) {
        discard;
    }

    // Allright we re valid in the volume
    float fragLightDistance = length(fragLightVec);
    float lightAttenuation = evalLightAttenuation(light, fragLightDistance);
    vec3 fragLightDir = fragLightVec / fragLightDistance;

    // Kill if not in the spot light (ah ah !)
    vec3 lightSpotDir = getLightDirection(light);
    float cosSpotAngle = max(-dot(fragLightDir, lightSpotDir), 0.0);
    if (cosSpotAngle < getLightSpotAngleCos(light)) {
       discard;
    }

    vec4 wNor = invViewMat * vec4(frag.normal, 0.0);
    vec4 fragEyeVector = invViewMat * vec4(-frag.position.xyz, 0.0);
    vec3 fragEyeDir = normalize(fragEyeVector.xyz);
    vec3 wHalfDir = normalize(fragEyeDir + fragLightDir);

    // Diffuse Lighting
    float diffuseDot = dot(wNor.xyz, fragLightDir);
    float facingLight = step(0.0, diffuseDot);
    vec3 diffuseColor = frag.diffuse * diffuseDot * facingLight;

    // compute the specular multiplier (sans exponent)
    float specularPower = facingLight * max(0.0, dot(fragEyeDir, wHalfDir));
    vec3 specularColor = pow(specularPower, frag.gloss * 128.0) * frag.specular;

    // Eval angular attenuation
    float lightAngularAttenuation = clamp((cosSpotAngle - getLightSpotAngleCos(light)) / (1.0 - getLightSpotAngleCos(light)), 0.0, 1.0);

    // Show edge
    float maxRadius = getLightRadius(light);
    float edge =  abs(2.0 * ((maxRadius - fragLightDistance) / (0.1)) - 1.0);
    if (cosSpotAngle < 1.01 * getLightSpotAngleCos(light)) {
       edge = 0;
    }
    if (edge < 1) {
        float edgeCoord = exp2(-8.0*edge*edge);
        gl_FragColor = vec4(edgeCoord * edgeCoord * getLightColor(light), 0.0);
    } else {
        gl_FragColor = vec4((diffuseColor + specularColor) * lightAngularAttenuation * lightAttenuation * getLightColor(light) * getLightIntensity(light), 0.0);
    }
}

