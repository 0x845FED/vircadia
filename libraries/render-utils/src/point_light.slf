<@include Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  spot_light.frag
//  fragment shader
//
//  Created by Andrzej Kapolka on 9/18/14.
//  Copyright 2014 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

// Everything about deferred buffer
<@include DeferredBuffer.slh@>

// Everything about light
<@include Light.slh@>


uniform mat4 invViewMat;



void main(void) {
    // get the depth and exit early if it doesn't pass the test
    vec2 texCoord = gl_TexCoord[0].st / gl_TexCoord[0].q;

    DeferredFragment frag = unpackDeferredFragment(texCoord);
      
    float depth = frag.depthVal;
    if (depth < gl_FragCoord.z) {
        discard;
    }

    vec4 wPos;
    wPos = invViewMat * frag.position;
    Light light = getLight();

    vec3 lightVector = getLightPosition(light) - wPos.xyz;
    if (dot(lightVector, lightVector) > getLightSquareRadius(light)) {
        discard;
    }

    float lightDistance = length(lightVector);
    vec3 lightDir = lightVector / lightDistance;

    float lightAttenuation = evalLightAttenuation(light, lightDistance);

    vec4 wNor = invViewMat * vec4(frag.normal, 0.0);
    vec4 wEyeVector = invViewMat * vec4(-frag.position.xyz, 0.0);
    vec3 eyeDir = normalize(wEyeVector.xyz);
    vec3 wHalfDir = normalize(eyeDir + lightDir);
    // Diffuse Lighting
    float diffuseDot = dot(wNor.xyz, lightDir);
    float facingLight = step(0.0, diffuseDot);
    vec3 diffuseColor = frag.diffuse * diffuseDot * facingLight;
        
    // compute the specular multiplier (sans exponent)
    float specularPower = facingLight * max(0.0,
                         dot(eyeDir, wHalfDir));    
    vec3 specularColor = pow(specularPower, frag.gloss * 128.0) * frag.specular;

    // add specular contribution
    gl_FragColor = vec4((diffuseColor + specularColor) * lightAttenuation * getLightColor(light) * getLightIntensity(light), 0.0);
}
