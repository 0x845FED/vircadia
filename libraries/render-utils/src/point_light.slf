<@include Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  spot_light.frag
//  fragment shader
//
//  Created by Andrzej Kapolka on 9/18/14.
//  Copyright 2014 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

// Everything about deferred buffer
<@include DeferredBuffer.slh@>

// Everything about light
<@include Light.slh@>

// The view Matrix
uniform mat4 invViewMat;

void main(void) {
    // get the depth and exit early if it doesn't pass the test
    vec2 texCoord = gl_TexCoord[0].st / gl_TexCoord[0].q;

    DeferredFragment frag = unpackDeferredFragment(texCoord);
      
    // Kill if in front of the light volume
    float depth = frag.depthVal;
    if (depth < gl_FragCoord.z) {
        discard;
    }

    // Need the light now
    Light light = getLight();

    // Make the Light vector going from fragment to light center in world space
    vec4 wPos;
    wPos = invViewMat * frag.position;
    vec3 lightVector = getLightPosition(light) - wPos.xyz;

    // Kill if too far from the light center
    if (dot(lightVector, lightVector) > getLightSquareRadius(light)) {
        discard;
    }

    // Allright we re valid in the volume
    float lightDistance = length(lightVector);
    float lightAttenuation = evalLightAttenuation(light, lightDistance);

    vec3 lightDir = lightVector / lightDistance;
    vec4 wNor = invViewMat * vec4(frag.normal, 0.0);
    vec4 wEyeVector = invViewMat * vec4(-frag.position.xyz, 0.0);
    vec3 eyeDir = normalize(wEyeVector.xyz);
    vec3 wHalfDir = normalize(eyeDir + lightDir);

    // Diffuse Lighting
    float diffuseDot = dot(wNor.xyz, lightDir);
    float facingLight = step(0.0, diffuseDot);
    vec3 diffuseColor = frag.diffuse * diffuseDot * facingLight;
        
    // compute the specular multiplier (sans exponent)
    float specularPower = facingLight * max(0.0,
                         dot(eyeDir, wHalfDir));    
    vec3 specularColor = pow(specularPower, frag.gloss * 128.0) * frag.specular;

    // Show edge
    float maxRadius = getLightRadius(light);
    float edge =  abs(2.0 * ((maxRadius - lightDistance) / (0.1)) - 1.0);
    if (edge < 1) {
        float edgeCoord = exp2(-8.0*edge*edge);
        gl_FragColor = vec4(edgeCoord * edgeCoord * getLightColor(light), 0.0);
    } else {
        gl_FragColor = vec4((diffuseColor + specularColor) * lightAttenuation * getLightColor(light) * getLightIntensity(light), 0.0);
    }
}
