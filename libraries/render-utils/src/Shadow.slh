<!
//  Shadow.slh
//  libraries/render-utils/src
//
//  Created by Sam Gateau on 1/4/15.
//  Copyright 2013 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
!>
<@if not SHADOW_SLH@>
<@def SHADOW_SLH@>

<@include Shadows_shared.slh@>

// the shadow texture
uniform sampler2DShadow shadowMaps[SHADOW_CASCADE_MAX_COUNT];

uniform shadowTransformBuffer {
	ShadowParameters shadow;
};

int getShadowCascadeCount() {
    return shadow.cascadeCount;
}

float getShadowCascadeMinDistance(int cascadeIndex) {
    return shadow.cascades[cascadeIndex].minDistance;
}

mat4 getShadowReprojection(int cascadeIndex) {
	return shadow.cascades[cascadeIndex].reprojection;
}

float getShadowScale() {
	return shadow.invMapSize;
}

float getShadowBias(int cascadeIndex) {
	return shadow.cascades[cascadeIndex].bias;
}

// Compute the texture coordinates from world coordinates
vec4 evalShadowTexcoord(int cascadeIndex, vec4 position) {
	float bias = -getShadowBias(cascadeIndex);

	vec4 shadowCoord = getShadowReprojection(cascadeIndex) * position;
	return vec4(shadowCoord.xy, shadowCoord.z + bias, 1.0);
}

// Sample the shadowMap with PCF (built-in)
float fetchShadow(int cascadeIndex, vec3 shadowTexcoord) {
    return texture(shadowMaps[cascadeIndex], shadowTexcoord);
}

vec2 PCFkernel[4] = vec2[4](
    vec2(-1.5, 0.5),
    vec2(0.5, 0.5),
    vec2(-1.5, -1.5),
    vec2(0.5, -1.5)
);

float evalShadowNoise(vec4 seed) {
    float dot_product = dot(seed, vec4(12.9898,78.233,45.164,94.673));
    return fract(sin(dot_product) * 43758.5453);
}

struct ShadowSampleOffsets {
    vec3 points[4];
};

ShadowSampleOffsets evalShadowFilterOffsets(vec4 position) {
	float shadowScale = getShadowScale();
    ShadowSampleOffsets offsets;

#if 0
    // Pattern dithering in screen space
    ivec2 coords = ivec2(gl_FragCoord.xy);
#else
    // Pattern dithering in world space (mm resolution)
    ivec2 coords = ivec2(position.x, position.y+position.z);
#endif
    // Add some noise to break dithering
    int index = int(4.0*evalShadowNoise(gl_FragCoord.xyyx))%4;
    coords.x += index & 1;
    coords.y += (index & 2) >> 1;

    // Offset for efficient PCF, see http://http.developer.nvidia.com/GPUGems/gpugems_ch11.html
    ivec2 offset = coords & ivec2(1,1);
    offset.y = (offset.x+offset.y) & 1;

    offsets.points[0] = shadowScale * vec3(offset + PCFkernel[0], 0.0);
    offsets.points[1] = shadowScale * vec3(offset + PCFkernel[1], 0.0);
    offsets.points[2] = shadowScale * vec3(offset + PCFkernel[2], 0.0);
    offsets.points[3] = shadowScale * vec3(offset + PCFkernel[3], 0.0);

    return offsets;
}

float evalShadowAttenuationPCF(int cascadeIndex, ShadowSampleOffsets offsets, vec4 shadowTexcoord) {

    float shadowAttenuation = 0.25 * (
        fetchShadow(cascadeIndex, shadowTexcoord.xyz + offsets.points[0]) +
        fetchShadow(cascadeIndex, shadowTexcoord.xyz + offsets.points[1]) +
        fetchShadow(cascadeIndex, shadowTexcoord.xyz + offsets.points[2]) +
        fetchShadow(cascadeIndex, shadowTexcoord.xyz + offsets.points[3])
    );

    return shadowAttenuation;
}

float evalShadowCascadeAttenuation(int cascadeIndex, vec4 position, ShadowSampleOffsets offsets) {
	vec4 shadowTexcoord = evalShadowTexcoord(cascadeIndex, position);
    if (shadowTexcoord.x < 0.0 || shadowTexcoord.x > 1.0 ||
        shadowTexcoord.y < 0.0 || shadowTexcoord.y > 1.0 ||
        shadowTexcoord.z < 0.0 || shadowTexcoord.z > 1.0) {
        // If a point is not in the map, do not attenuate
        return 1.0;
    }
    return evalShadowAttenuationPCF(cascadeIndex, offsets, shadowTexcoord);
}

float evalShadowAttenuation(vec4 position) {
    ShadowSampleOffsets offsets = evalShadowFilterOffsets(position);

    // Cascade selection based on :
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ee416307(v=vs.85).aspx
    vec4 currentPixelDepth = position.zzzz;
    vec4 cascadeDepthLimits = vec4(
        getShadowCascadeMinDistance(0),
        getShadowCascadeMinDistance(1),
        getShadowCascadeMinDistance(2),
        getShadowCascadeMinDistance(3)
    );
    bvec4 comparison = greaterThan( currentPixelDepth, cascadeDepthLimits);
    int cascadeCount = getShadowCascadeCount();
    bvec4 cascadeCountMask = greaterThan(ivec4(cascadeCount), ivec4(0,1,2,3));
    int cascadeIndex = int(dot(ivec4(cascadeCountMask), ivec4(comparison)));
    cascadeIndex = min( cascadeIndex, cascadeCount-1 );
	
    return evalShadowCascadeAttenuation(cascadeIndex, position, offsets);
}

<@endif@>
