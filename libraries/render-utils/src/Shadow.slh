<!
//  Shadow.slh
//  libraries/render-utils/src
//
//  Created by Sam Gateau on 1/4/15.
//  Copyright 2013 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
!>
<@if not SHADOW_SLH@>
<@def SHADOW_SLH@>

// the shadow texture
uniform sampler2DShadow shadowMap;

struct ShadowTransform {
	mat4 projection;
	mat4 view;

	float bias;
	float scale;
};

uniform shadowTransformBuffer {
	ShadowTransform _shadowTransform;
};

mat4 getShadowView() {
	return _shadowTransform.view;
}

mat4 getShadowProjection() {
	return _shadowTransform.projection;
}

float getShadowScale() {
	return 1.0;
	//_shadowTransform.scale;
}

// Compute the texture coordinates from world coordinates
vec4 evalShadowTexcoord(vec4 position) {
	mat4 bias = mat4(
		0.5, 0.0, 0.0, 0.0,
		0.0, 0.5, 0.0, 0.0,
		0.0, 0.0, 0.5, 0.0,
		0.5, 0.5, 0.5, 1.0);
	return bias * getShadowProjection() * inverse(getShadowView()) * position;
}

// Fetching it
float fetchShadow(vec3 shadowTexcoord) {
    return texture(shadowMap, shadowTexcoord);
}

vec2 samples[8] = vec2[8](
    vec2(-2.0, -2.0),
    vec2(2.0, -2.0),
    vec2(2.0, 2.0),
    vec2(-2.0, 2.0),
    vec2(1.0, 0.0),
    vec2(0.0, 1.0),
    vec2(-1.0, 0.0),
    vec2(0.0, -1.0)
);

float evalShadowAttenuationPCF(vec4 shadowTexcoord) {
    float radiusScale = (shadowTexcoord.w + 1.0);
	float shadowScale = getShadowScale();

    float shadowAttenuation = (0.25 * (
        fetchShadow(shadowTexcoord.xyz + radiusScale * shadowScale * vec3(samples[0], 0.0)) +
        fetchShadow(shadowTexcoord.xyz + radiusScale * shadowScale * vec3(samples[1], 0.0)) +
        fetchShadow(shadowTexcoord.xyz + radiusScale * shadowScale * vec3(samples[2], 0.0)) +
        fetchShadow(shadowTexcoord.xyz + radiusScale * shadowScale * vec3(samples[3], 0.0))
    ));

    if ((shadowAttenuation > 0) && (shadowAttenuation < 1.0)) {
        radiusScale *= 0.5;
        shadowAttenuation = 0.5 * shadowAttenuation + (0.125 * (
            fetchShadow(shadowTexcoord.xyz + radiusScale * shadowScale * vec3(samples[4], 0.0)) +
            fetchShadow(shadowTexcoord.xyz + radiusScale * shadowScale * vec3(samples[5], 0.0)) +
            fetchShadow(shadowTexcoord.xyz + radiusScale * shadowScale * vec3(samples[6], 0.0)) +
            fetchShadow(shadowTexcoord.xyz + radiusScale * shadowScale * vec3(samples[7], 0.0))
        ));
    }

    return shadowAttenuation;
}

float evalShadowAttenuationBasic(vec4 shadowTexcoord) {
    float radiusScale = 0.5;
	float shadowScale = getShadowScale();

    float shadowAttenuation = (0.25 * (
        fetchShadow(shadowTexcoord.xyz + radiusScale * shadowScale * vec3(samples[0], 0.0)) +
        fetchShadow(shadowTexcoord.xyz + radiusScale * shadowScale * vec3(samples[1], 0.0)) +
        fetchShadow(shadowTexcoord.xyz + radiusScale * shadowScale * vec3(samples[2], 0.0)) +
        fetchShadow(shadowTexcoord.xyz + radiusScale * shadowScale * vec3(samples[3], 0.0))
    ));

    return shadowAttenuation;
}

float evalShadowAttenuation(vec4 position) {
	vec4 shadowTexcoord = evalShadowTexcoord(position);

	return fetchShadow(shadowTexcoord.xyz);
    // return evalShadowAttenuationBasic(shadowTexcoord);
    // return evalShadowAttenuationPCF(shadowTexcoord);
}

<@endif@>
