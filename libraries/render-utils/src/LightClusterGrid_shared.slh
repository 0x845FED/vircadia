// glsl / C++ compatible source as interface for FrustrumGrid
float frustumGrid_depthRamp(float linear) {
    // return linear;
    return linear * linear;
}
float frustumGrid_depthRampInverse(float volume) {
    //  return volume;
    return sqrt(volume);
}

vec3 frustumGrid_gridToVolume(vec3 pos, ivec3 dims) {
    vec3 gridScale = vec3(1.0, 1.0, 1.0) / vec3(dims);
    vec3 volumePos = pos * gridScale;
    volumePos.z = frustumGrid_depthRamp(volumePos.z);
    return volumePos;
}


float frustumGrid_volumeToGridDepth(float vposZ, ivec3 dims) {
    return frustumGrid_depthRampInverse(vposZ) * float(dims.z);
}

vec3 frustumGrid_volumeToGrid(vec3 vpos, ivec3 dims) {
    vec3 gridPos = vec3(vpos.x, vpos.y, frustumGrid_depthRampInverse(vpos.z)) * vec3(dims);
    return gridPos;
}


vec4 frustumGrid_volumeToClip(vec3 vpos, float rangeNear, float rangeFar) {
    vec3 ndcPos = vec3(-1.0 + 2.0 * vpos.x, -1.0 + 2.0 * vpos.y, vpos.z);
    float depth = rangeNear * (1 - ndcPos.z) + rangeFar * (ndcPos.z);
    vec4 clipPos = vec4(ndcPos.x * depth, ndcPos.y * depth, 1.0, depth);
    return clipPos;
}

vec3 frustumGrid_clipToEye(vec4 clipPos, mat4 projection) {
    return vec3(
        (clipPos.x + projection[2][0] * clipPos.w) / projection[0][0],
        (clipPos.y + projection[2][1] * clipPos.w) / projection[1][1],
        -clipPos.w
        //, (clipPos.z - projection[3][3] * clipPos.w) / projection[3][2]
        );
}

vec3 frustumGrid_volumeToEye(vec3 vpos, mat4 projection, float rangeNear, float rangeFar) {
    return frustumGrid_clipToEye(frustumGrid_volumeToClip(vpos, rangeNear, rangeFar), projection);
}

float frustumGrid_eyeToVolumeDepth(float eposZ, float rangeNear, float rangeFar) {
    return (-eposZ - rangeNear) / (rangeFar - rangeNear);
}


vec3 frustumGrid_eyeToVolume(vec3 epos, mat4 projection, float rangeNear, float rangeFar) {
    vec4 clipPos = vec4(epos.x * projection[0][0] + epos.z * projection[2][0],
        epos.y * projection[1][1] + epos.z * projection[2][1],
        epos.z * projection[2][2] + projection[2][3],
        -epos.z);
    vec4 ndcPos = clipPos / clipPos.w;

    vec3 volumePos = vec3(0.5 * (ndcPos.x + 1.0), 0.5 * (ndcPos.y + 1.0), (clipPos.w - rangeNear) / (rangeFar - rangeNear));
    return volumePos;
}



int frustumGrid_numClusters() {
    return frustumGrid.dims.x * frustumGrid.dims.y * (frustumGrid.dims.z + 1);
}

vec3 frustumGrid_clusterPosToEye(ivec3 clusterPos, vec3 offset) {

    vec3 cvpos = vec3(clusterPos) + offset;


    vec3 volumePos = frustumGrid_gridToVolume(cvpos, frustumGrid.dims);

    vec3 eyePos = frustumGrid_volumeToEye(volumePos, frustumGrid.eyeToGridProj, frustumGrid.rangeNear, frustumGrid.rangeFar);

    return eyePos;
}


int frustumGrid_eyeDepthToClusterLayer(float eyeZ) {
    if ((eyeZ > -frustumGrid.frustumNear) || (eyeZ < -frustumGrid.frustumFar)) {
        return -1;
    }

    if (eyeZ > -frustumGrid.rangeNear) {
        return -1;
    }

    float volumeZ = frustumGrid_eyeToVolumeDepth(eyeZ, frustumGrid.rangeNear, frustumGrid.rangeFar);

    float gridZ = frustumGrid_volumeToGridDepth(volumeZ, frustumGrid.dims);

    if (gridZ >= frustumGrid.dims.z) {
        gridZ = frustumGrid.dims.z;
    }


    return int(gridZ);
}

ivec3 frustumGrid_eyeToClusterPos(vec3 eyePos) {
    if ((eyePos.z > -frustumGrid.frustumNear) || (eyePos.z < -frustumGrid.frustumFar)) {
        return ivec3(-1);
    }
    
    if (eyePos.z > -frustumGrid.rangeNear) {
        return ivec3(0,0,-1);
    }
    
    vec3 volumePos = frustumGrid_eyeToVolume(eyePos, frustumGrid.eyeToGridProj, frustumGrid.rangeNear, frustumGrid.rangeFar);

    vec3 gridPos = frustumGrid_volumeToGrid(volumePos, frustumGrid.dims);
    
    if (gridPos.z >= frustumGrid.dims.z) {
        gridPos.z = frustumGrid.dims.z;
    }


    return ivec3(gridPos);
}

int frustumGrid_eyeToClusterDirH(vec3 eyeDir) {
    if (eyeDir.z >= 0.0) {
        return (eyeDir.x > 0 ? frustumGrid.dims.x : -1);
    }

    float eyeDepth = -eyeDir.z;
    float nclipDir = eyeDir.x / eyeDepth;
    float ndcDir = nclipDir * frustumGrid.eyeToGridProj[0][0] - frustumGrid.eyeToGridProj[2][0];
    float volumeDir = 0.5 * (ndcDir + 1.0);
    float gridPos = volumeDir * float(frustumGrid.dims.x);

    return int(gridPos);
}

int frustumGrid_eyeToClusterDirV(vec3 eyeDir) {
    if (eyeDir.z >= 0.0) {
        return (eyeDir.y > 0 ? frustumGrid.dims.y : -1);
    }

    float eyeDepth = -eyeDir.z;
    float nclipDir = eyeDir.y / eyeDepth;
    float ndcDir = nclipDir * frustumGrid.eyeToGridProj[1][1] - frustumGrid.eyeToGridProj[2][1];
    float volumeDir = 0.5 * (ndcDir + 1.0);
    float gridPos = volumeDir * float(frustumGrid.dims.y);

    return int(gridPos);
}

ivec2 frustumGrid_eyeToClusterDir(vec3 eyeDir) {
    return ivec2(frustumGrid_eyeToClusterDirH(eyeDir), frustumGrid_eyeToClusterDirV(eyeDir));
}

vec4 frustumGrid_eyeToWorld(vec4 eyePos) {
    return frustumGrid.eyeToWorldMat * eyePos;
}

vec4 frustumGrid_worldToEye(vec4 worldPos) {
    return frustumGrid.worldToEyeMat * worldPos;
}



    // <@if 1@>
    // Trigger Scribe include 
    // <@endif@> <!def that !> End C++ compatible