<!
//  MaterialTextures.slh
//  fragment shader
//
//  Created by Sam Gateau on 2/22/16
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
!>
<@if not MODEL_MATERIAL_TEXTURES_SLH@>
<@def MODEL_MATERIAL_TEXTURES_SLH@>

<@func declareMaterialTextures(withAlbedo, withRoughness, withNormal, withMetallic)@>

<@if withAlbedo@>
uniform sampler2D albedoMap;
vec4 fetchAlbedoMap(vec2 uv) {
    return texture(albedoMap, uv);
}
<@endif@>

<!
<@if withRoughness@>
uniform sampler2D roughnessMap;
float fetchRoughnessMap(vec2 uv) {
    return texture(roughnessMap, uv).r;
}
<@endif@>
!>

<@if withNormal@>
uniform sampler2D normalMap;
vec3 fetchNormalMap(vec2 uv) {
    return texture(normalMap, uv).xyz;
}
<@endif@>

<@if withMetallic@>
uniform sampler2D specularMap;
vec3 fetchMetallicMap(vec2 uv) {
    return texture(specularMap, uv).rgb;
}
<@endif@>

<@endfunc@>


<@func fetchMaterialTextures(texcoord0, albedo, roughness, normal, metallic)@>
<@if albedo@>
    vec4 <$albedo$> = fetchAlbedoMap(<$texcoord0$>);
<@endif@>
<@if roughness@>
float <$roughness$> = 1.0; //fetchRoughnessMap(<$texcoord0$>);
<@endif@>
<@if normal@>
    vec3 <$normal$> = fetchNormalMap(<$texcoord0$>);
<@endif@>
<@if metallic@>
    vec3 <$metallic$> = fetchMetallicMap(<$texcoord0$>);
<@endif@>
<@endfunc@>


<@func declareMaterialLightmap()@>
uniform sampler2D emissiveMap;
uniform vec2 emissiveParams;
vec3 fetchLightmapMap(vec2 uv) {
    return (vec3(emissiveParams.x) + emissiveParams.y * texture(emissiveMap, uv).rgb);
}
<@endfunc@>

<@func fetchMaterialLightmap(texcoord1, lightmapVal)@>
    vec3 <$lightmapVal$> = fetchLightmapMap(<$texcoord1$>);
<@endfunc@>


<@func tangentToViewSpace(fetchedNormal, interpolatedNormal, interpolatedTangent, normal)@>
{
    vec3 normalizedNormal = normalize(<$interpolatedNormal$>.xyz);
    vec3 normalizedTangent = normalize(<$interpolatedTangent$>.xyz);
    vec3 normalizedBitangent = normalize(cross(normalizedNormal, normalizedTangent));
    vec3 localNormal = normalize(<$fetchedNormal$> - vec3(0.5, 0.5, 0.5));
    <$normal$> = vec3(normalizedTangent * localNormal.x + normalizedBitangent * localNormal.y + normalizedNormal * localNormal.z);
}
<@endfunc@>

<@endif@>