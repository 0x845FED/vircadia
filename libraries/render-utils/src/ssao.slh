<!
//  AmbientOcclusion.slh
//  libraries/render-utils/src
//
//  Created by Sam Gateau on 1/1/16.
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
!>
<@if not SSAO_SLH@>
<@def SSAO_SLH@>

<@include render-utils/ShaderConstants.h@>

<@func declarePackOcclusionDepth()@>

const float FAR_PLANE_Z = -300.0;

float CSZToDepthKey(float z) {
    return clamp(z * (1.0 / FAR_PLANE_Z), 0.0, 1.0);
}
vec3 packOcclusionDepth(float occlusion, float depth) {
    // Round to the nearest 1/256.0
    float temp = floor(depth * 256.0);
    return vec3(occlusion, temp * (1.0 / 256.0), depth * 256.0 - temp);
}
vec2 unpackOcclusionDepth(vec3 raw) {
    float z = raw.y * (256.0 / 257.0) + raw.z * (1.0 / 257.0);
    return vec2(raw.x, z);
}
<@endfunc@>

<@func declareAmbientOcclusion()@>
<@include DeferredTransform.slh@>
<$declareDeferredFrameTransform()$>

struct AmbientOcclusionParams {
    vec4 _resolutionInfo;
    vec4 _radiusInfo;
    vec4 _ditheringInfo;
    vec4 _sampleInfo;
    vec4 _blurInfo;
    float _gaussianCoefs[16];
};

layout(binding=RENDER_UTILS_BUFFER_SSAO_PARAMS) uniform ambientOcclusionParamsBuffer {
    AmbientOcclusionParams params;
};


float getPerspectiveScale() {
    
    return (params._resolutionInfo.z);
}
int getResolutionLevel() {
    
    return int(params._resolutionInfo.x);
}

float getRadius() {
    return params._radiusInfo.x;
}
float getRadius2() {
    return params._radiusInfo.y;
}
float getInvRadius6() {
    return params._radiusInfo.z;
}

float getObscuranceScaling() {
    return params._radiusInfo.z * params._radiusInfo.w;
}

float isDitheringEnabled() {
    return params._ditheringInfo.x;
}
float getFalloffDistance() {
    return params._ditheringInfo.y;
}
float isBorderingEnabled() {
    return params._ditheringInfo.w;
}

float getFalloffAngle() {
    return params._ditheringInfo.z;
}

float getNumSamples() {
    return params._sampleInfo.x;
}
float getInvNumSamples() {
    return params._sampleInfo.y;
}
float getNumSpiralTurns() {
    return params._sampleInfo.z;
}

int doFetchMips() {
    return int(params._sampleInfo.w);
}

float getBlurEdgeSharpness() {
    return params._blurInfo.x;
}

#ifdef CONSTANT_GAUSSIAN
const int BLUR_RADIUS = 4;
const float gaussian[BLUR_RADIUS + 1] =
// KEEP this dead code for eventual performance improvment
//    float[](0.356642, 0.239400, 0.072410, 0.009869);
//    float[](0.398943, 0.241971, 0.053991, 0.004432, 0.000134);  // stddev = 1.0
float[](0.153170, 0.144893, 0.122649, 0.092902, 0.062970);  // stddev = 2.0
//float[](0.197413, 0.17467, 0.12098,0.065591,0.040059);
//      float[](0.111220, 0.107798, 0.098151, 0.083953, 0.067458, 0.050920, 0.036108); // stddev = 3.0

int getBlurRadius() {
    return BLUR_RADIUS;
}

float getBlurCoef(int c) {
    return gaussian[c];
}
#else
int getBlurRadius() {
    return int(params._blurInfo.y);
}

float getBlurCoef(int c) {
    return params._gaussianCoefs[c];
}
#endif

<@endfunc@>

<@func declareSamplingDisk()@>

float getAngleDitheringWorldPos(in vec3 pixelWorldPos) {
    vec3 worldPosFract = fract(pixelWorldPos * 1.0);

    ivec3 pixelPos = ivec3(worldPosFract * 256.0);

    return isDitheringEnabled() * float(((3 * pixelPos.x ^ pixelPos.y + pixelPos.x * pixelPos.y) + (3 * pixelPos.y ^ pixelPos.z + pixelPos.x * pixelPos.z)) * 10);
}

float getAngleDithering(in ivec2 pixelPos) {
    // Hash function used in the AlchemyAO paper
    return isDitheringEnabled() * float((3 * pixelPos.x ^ pixelPos.y + pixelPos.x * pixelPos.y) * 10);
}

float evalDiskRadius(float Zeye, vec2 imageSize) {
    // Choose the screen-space sample radius
    // proportional to the projected area of the sphere
    float ssDiskRadius = -( getProjScale(getResolutionLevel()) * getRadius() / Zeye ) * getPerspectiveScale();

    // clamp the disk to fit in the image otherwise too many unknown
    ssDiskRadius = min(ssDiskRadius, imageSize.y * 0.5);

    return ssDiskRadius;
}

const float PI = 3.1415926;
const float TWO_PI = 6.2831852;

vec3 getUnitTapLocation(int sampleNumber, float spiralTurns, float spinAngle, float angleRange){
    // Radius relative to ssR
    float alpha = float(sampleNumber + 0.5) * getInvNumSamples();
    float angle = alpha * (spiralTurns * angleRange) + spinAngle;
    return vec3(cos(angle), sin(angle), alpha);
}

vec3 getTapLocationSSAO(int sampleNumber, float spinAngle, float outerRadius) {
    vec3 tap = getUnitTapLocation(sampleNumber, getNumSpiralTurns(), spinAngle, TWO_PI);
    tap.xy *= tap.z;
    tap *= outerRadius;
    return tap;
}

vec3 getTapLocationClampedSSAO(int sampleNumber, float spinAngle, float outerRadius, vec2 pixelPos, vec2 imageSize) {
    vec3 tap = getTapLocationSSAO(sampleNumber, spinAngle, outerRadius);
    vec2 tapPos = pixelPos + tap.xy;

    if (!(isBorderingEnabled() > 0.0)) {
        return tap;
    }
    bool redoTap = false;

    if ((tapPos.x < 0.5)) {
        tapPos.x = -tapPos.x;
        redoTap = true;
    } else if ((tapPos.x > imageSize.x - 0.5)) {
        tapPos.x -= (imageSize.x - tapPos.x);
        redoTap = true;
    }

    if ((tapPos.y < 0.5)) {
        tapPos.y = -tapPos.y;
        redoTap = true;
    } else if ((tapPos.y > imageSize.y - 0.5)) {
        tapPos.y -= (imageSize.y - tapPos.y);
        redoTap = true;
    }

    if (redoTap) {
        tap.xy = tapPos - pixelPos;
        tap.z = length(tap.xy);
        tap.z = 0.0;  
    }
    
    return tap;
}

<@endfunc@>


<@func declareFetchDepthPyramidMap()@>

// the depth pyramid texture
layout(binding=RENDER_UTILS_TEXTURE_SSAO_PYRAMID) uniform sampler2D pyramidMap;

float getZEyeAtPixel(ivec2 pixel, int level) {
    return -texelFetch(pyramidMap, pixel, level).x;
}

float getZEyeAtUV(vec2 texCoord, int level) {
    return -texture(pyramidMap, texCoord, level).x;
}

const int LOG_MAX_OFFSET = 1;
const int MAX_MIP_LEVEL = 5;
int evalMipFromRadius(float radius) {
    //  mipLevel = floor(log(ssR / MAX_OFFSET));
    return clamp(findMSB(int(radius)) - LOG_MAX_OFFSET, 0, MAX_MIP_LEVEL);
}

vec3 fetchTapUnfiltered(ivec4 side, ivec2 ssC, vec3 tap, vec2 imageSize) {
    ivec2 ssP = ivec2(tap.xy) + ssC;
    ivec2 ssPFull = ivec2(ssP.x + side.y, ssP.y);


    vec2 tapUV = (vec2(ssP) + vec2(0.5)) / imageSize;

    vec2 fetchUV = vec2(tapUV.x + float(side.w) * 0.5 * (float(side.x) - tapUV.x), tapUV.y);

    vec3 P;
    P.xy = tapUV;
    P.z = -texture(pyramidMap, fetchUV).x;

   return P;
}

vec4 fetchTap(ivec4 side, ivec2 ssC, vec3 tap, vec2 imageSize) {
    int mipLevel = evalMipFromRadius(tap.z * float(doFetchMips()));

    vec2 ssP = tap.xy + vec2(ssC);

    // We need to divide by 2^mipLevel to read the appropriately scaled coordinate from a MIP-map.
    // Manually clamp to the texture size because texelFetch bypasses the texture unit
    vec2 tapUV = (vec2(ssP) + vec2(0.5)) / imageSize;
    vec2 fetchUV = vec2(tapUV.x + side.w * 0.5 * (side.x - tapUV.x), tapUV.y);

    vec4 P;
    P.xy = tapUV;
    P.w = float(mipLevel);
    P.z = -textureLod(pyramidMap, fetchUV, P.w).x;
   return P;
}

<@endfunc@>


<@func declareEvalObscurance()@>

vec3 fastAcos(vec3 x) {
	// [Eberly2014] GPGPU Programming for Games and Science
	vec3 absX = abs(x);
	vec3 res = absX * (-0.156583) + vec3(PI / 2.0);
	res *= sqrt(vec3(1.0) - absX);
	return mix(res, vec3(PI) - res, greaterThanEqual(x, vec3(0)));
}

float evalVisibilitySSAO(in vec3 centerPosition, in vec3 centerNormal, in vec3 tapPosition) {
    vec3 v = tapPosition - centerPosition;
    float vv = dot(v, v);
    float vn = dot(v, centerNormal);

    // Fall off function as recommended in SSAO paper
    const float epsilon = 0.01;
    float f = max(getRadius2() - vv, 0.0);
    return f * f * f * max((vn - getFalloffAngle()) / (epsilon + vv), 0.0);
}

float computeHorizonFromTap(vec3 tapPositionES, vec3 fragPositionES, vec3 fragNormalES) {
    vec3 deltaVec = tapPositionES - fragPositionES;
    float distanceSquared = dot(deltaVec, deltaVec);
    float rawHorizon = dot(normalize(deltaVec), fragNormalES);
    float radiusFalloff = distanceSquared / getRadius2();

    rawHorizon = max(0.0, (rawHorizon - getFalloffAngle()) / (1.0 - getFalloffAngle()));
    rawHorizon *= max(0.0, 1.0 - radiusFalloff);

    return rawHorizon;
}

<@func computeHorizon()@>
            vec3 tap = vec3(tapPixelPos, radius);
            vec4 tapUVZ_mip = fetchTap(side, centerPixelPos, tap, imageSize);
            vec3 tapPositionES = evalEyePositionFromZeye(side.x, tapUVZ_mip.z, tapUVZ_mip.xy);
            float rawHorizon = computeHorizonFromTap(tapPositionES, fragPositionES, fragNormalES);

            <$horizon$> = max(<$horizon$>, rawHorizon);
<@endfunc@>

#define SSAO_LINEAR_SAMPLING 1

<@func updateHorizon(horizon, deltaPixelTap)@>
    {
        vec2 deltaPixelTap = clampedSearchVec / float(stepCount);
        float searchRadius = length(clampedSearchVec);
        float deltaRadius = searchRadius / float(stepCount);
        vec2 tapPixelPos = vec2(0);

#if !SSAO_LINEAR_SAMPLING
        float radius = deltaRadius;
        float mipLevel = evalMipFromRadius(radius * float(doFetchMips()));

        while (radius<searchRadius) {
            tapPixelPos += <$deltaPixelTap$>;

            <$computeHorizon()$>

            if (tapUVZ_mip.w != mipLevel) {
                mipLevel = tapUVZ_mip.w;
                deltaRadius *= 2;
                <$deltaPixelTap$> *= 2;
            }
            radius += deltaRadius;
        }
#else
        float radius = 0.0;
        int stepIndex;

        for (stepIndex=0 ; stepIndex<stepCount ; stepIndex++) {
            tapPixelPos += <$deltaPixelTap$>;
            radius += deltaRadius;

            <$computeHorizon()$>
        }
#endif
    }
<@endfunc@>

vec2 clampSearchVec(vec2 imageSize, vec2 centerPixelPos, vec2 searchVec) {
    vec2 clampdSearchVec = searchVec;
    vec2 endPixel = centerPixelPos + clampdSearchVec;

    if (endPixel.x < 0) {
        clampdSearchVec = clampdSearchVec * ((0-centerPixelPos.x) / clampdSearchVec.x);
        endPixel = centerPixelPos + clampdSearchVec;
    }
    if (endPixel.x >= imageSize.x) {
        clampdSearchVec = clampdSearchVec * ((imageSize.x-1-centerPixelPos.x) / clampdSearchVec.x);
        endPixel = centerPixelPos + clampdSearchVec;
    }
    if (endPixel.y < 0) {
        clampdSearchVec = clampdSearchVec * ((0-centerPixelPos.y) / clampdSearchVec.y);
        endPixel = centerPixelPos + clampdSearchVec;
    }
    if (endPixel.y >= imageSize.y) {
        clampdSearchVec = clampdSearchVec * ((imageSize.y-1-centerPixelPos.y) / clampdSearchVec.y);
    }

    return clampdSearchVec;
}

vec2 searchHorizons(ivec4 side, ivec2 centerPixelPos, vec2 imageSize, vec2 deltaTap, float ssDiskRadius, 
                    vec3 fragPositionES, vec3 fragNormalES) {
	vec2 searchVec = deltaTap * ssDiskRadius;
	vec2 horizons = vec2(0.0);

    // Forward search for h1
    vec2 clampedSearchVec = clampSearchVec(imageSize, vec2(centerPixelPos), searchVec);
    vec2 absClampedSearchVec = abs(clampedSearchVec);
    int stepCount = int(max(absClampedSearchVec.x, absClampedSearchVec.y));
    if (stepCount>0) {
        <$updateHorizon(horizons.x, deltaPixelTap)$>
    }
    // Backward search for h2
    clampedSearchVec = clampSearchVec(imageSize, vec2(centerPixelPos), -searchVec);
    absClampedSearchVec = abs(clampedSearchVec);
    stepCount = int(max(absClampedSearchVec.x, absClampedSearchVec.y));
    if (stepCount>0) {
        <$updateHorizon(horizons.y, deltaPixelTap)$>
    }

	return horizons;
}

float evalVisibilityHBAO(ivec4 side, ivec2 centerPixelPos, vec2 imageSize, vec2 deltaTap, float ssDiskRadius, 
                         vec3 fragPositionES, vec3 fragNormalES) {
	vec2 horizons = searchHorizons(side, centerPixelPos, imageSize, deltaTap, ssDiskRadius, fragPositionES, fragNormalES);
	return (horizons.x + horizons.y) * 0.5 / PI;
}

<@endfunc@>

<@func declareBlurPass(axis)@>

<$declarePackOcclusionDepth()$>
<$declareAmbientOcclusion()$>
<$declareFetchDepthPyramidMap()$>

// the source occlusion texture
layout(binding=RENDER_UTILS_TEXTURE_SSAO_OCCLUSION) uniform sampler2D occlusionMap;

struct BlurParams {
    vec4 scaleHeight;
};

layout(binding=RENDER_UTILS_BUFFER_SSAO_BLUR_PARAMS) uniform blurParamsBuffer {
    BlurParams blurParams;
};

float getOcclusionBlurScale() {
    return blurParams.scaleHeight.x;
}

float getDepthBlurScale() {
    return blurParams.scaleHeight.y;
}

int getBlurImageHeight() {
    return int(blurParams.scaleHeight.z);
}

float fetchOcclusion(vec2 coords) {
    vec3 raw = texture(occlusionMap, coords, 0).xyz;
    return raw.x;
}

const float BLUR_WEIGHT_OFFSET = 0.01;
const float BLUR_EDGE_SCALE = 300.0;

vec2 evalTapWeightedValue(ivec3 side, int r, ivec2 destPixelCoord, vec2 scaledTexCoord, vec2 fullTexCoord, float key) {
    ivec2 tapOffset = <$axis$> * r;
    ivec2 tapPixelCoord = destPixelCoord + tapOffset;

    if ((tapPixelCoord.x < side.y || tapPixelCoord.x >= side.z + side.y) || (tapPixelCoord.y < 0 || tapPixelCoord.y >= getBlurImageHeight())) {
        return vec2(0.0);
    }
    vec2 tapTexCoord = scaledTexCoord + tapOffset * getOcclusionBlurScale();
    float tapOcclusion = fetchOcclusion(tapTexCoord);

    tapTexCoord = fullTexCoord + tapOffset * getDepthBlurScale();
    float tapDepth = getZEyeAtUV(tapTexCoord, 0);

    // spatial domain: offset gaussian tap
    float weight = BLUR_WEIGHT_OFFSET + getBlurCoef(abs(r));

    // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
//    weight *= max(0.0, 1.0 - (getBlurEdgeSharpness() * BLUR_EDGE_SCALE) * abs(tapDepth - key));
    float zDistance = tapDepth - key;
    weight *= exp(-(getBlurEdgeSharpness() * BLUR_EDGE_SCALE) * zDistance * zDistance);
    
    return vec2(tapOcclusion * weight, weight);
}

vec3 getBlurredOcclusion(ivec2 destPixelCoord, vec2 scaledTexCoord, vec2 fullTexCoord) {
    // Stereo side info
    ivec4 side = getStereoSideInfo(destPixelCoord.x, 0);

    float pixelDepth = getZEyeAtUV(fullTexCoord, 0);
    vec2 weightedSums = vec2(0.0);
    
    // Accumulate weighted contributions along the bluring axis in the [-radius, radius] range
    int blurRadius = getBlurRadius();
    // negative side first
    for (int r = -blurRadius; r <= -1; ++r) {
        weightedSums += evalTapWeightedValue(side.xyz, r, destPixelCoord, scaledTexCoord, fullTexCoord, pixelDepth);
    }
    
    // Central pixel contribution
    float mainWeight = getBlurCoef(0);
    float pixelOcclusion = fetchOcclusion(scaledTexCoord);
    weightedSums += vec2(pixelOcclusion * mainWeight, mainWeight);

    // then positive side
    for (int r = 1; r <= blurRadius; ++r) {
        weightedSums += evalTapWeightedValue(side.xyz, r, destPixelCoord, scaledTexCoord, fullTexCoord, pixelDepth);
    }

    // Final normalization
    const float epsilon = 0.0001;
    float result = weightedSums.x / (weightedSums.y + epsilon);
    
    return vec3(result);
}

<@endfunc@>


<@endif@>