<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  Created by Sam Gateau on 6/3/16.
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include DeferredTransform.slh@>
<$declareDeferredFrameTransform()$>


uniform sampler2D depthMap;

out vec4 outFragColor;
/*
void main(void) {
    float Zdb = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;
    float Zeye = -evalZeyeFromZdb(Zdb);
    outFragColor = vec4(Zeye, 0.0, 0.0, 1.0);
}
*/

void main(void) {
    // Pixel being shaded
    ivec2 pixelPos;
    vec2 nclipPos;
    ivec3 stereoSide;
    ivec2 framePixelPos = getPixelPosNclipPosAndSide(gl_FragCoord.xy, pixelPos, nclipPos, stereoSide);

    // Fetch the z under the pixel (stereo or not)
    float Zdb = texelFetch(depthMap, pixelPos, 0).x;
    float Zeye = -evalZeyeFromZdb(Zdb);


    // The position  and normal of the pixel fragment in Eye space
    vec3 eyePos = evalEyePositionFromZeye(stereoSide.x, Zeye, nclipPos);

    vec3 worldPos = (frameTransform._invView * vec4(eyePos, 1.0)).xyz;

    vec3 moduloPos = fract(worldPos);

    outFragColor = vec4(moduloPos, 1.0);
    /*
    return;

    // Choose the screen-space sample radius
    // proportional to the projected area of the sphere
    float ssDiskRadius = -getProjScale() * getRadius() / Cp.z;


    vec2 texUV = gl_FragCoord.xy * getInvWidthHeight();
    float Zdb = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;
    float Zeye = -evalZeyeFromZdb(Zdb);

    ivec3 stereoInfo = getStereoSideInfo(gl_FragCoord.x, 0);

    // World Pos
    vec4 samplePos = evalEyePositionFromZeye(stereoInfo.x, )

    // Calculate the width scale.
    ./ Choose the screen-space sample radius
    // proportional to the projected area of the sphere
   // float ssDiskRadius = -getProjScale() * getRadius() / Cp.z;

  //  float distanceToProjectionWindow = 1.0f / tan(0.5f * radians(fov));
    float scale = getProjScaleEye() / Zeye;
    
    vec2 viewportScale = scale * getInvWidthHeight();

    // Calculate dF/du and dF/dv
    vec2 du = vec2( 1.0f, 0.0f ) * viewportScale.x;
    vec2 dv = vec2( 0.0f, 1.0f ) * viewportScale.y;

    vec4 dFdu = texture(depthMap, texUV + du.xy) - texture(depthMap, texUV - du.xy);
    vec4 dFdv = texture(depthMap, texUV + dv.xy) - texture(depthMap, texUV - dv.xy);
    dFdu *= step(abs(dFdu.w), 0.1f); dFdv *= step(abs(dFdv.w), 0.1f); 
    
    // Calculate ( du/dx, du/dy, du/dz ) and ( dv/dx, dv/dy, dv/dz )
    float dist = 1.0f; samplePos.w = 1.0f;
    vec2 centerOffset = ((input.texUV - 0.5f) * 2.0f);
    vec4 px =  mul( samplePos + vec4( dist, 0.0f, 0.0f, 0.0f ), matViewProj );
    vec4 py =  mul( samplePos + vec4( 0.0f, dist, 0.0f, 0.0f ), matViewProj );
    vec4 pz =  mul( samplePos + vec4( 0.0f, 0.0f, dist, 0.0f ), matViewProj );
    #ifdef INVERT_TEXTURE_V
        centerOffset.y = -centerOffset.y;
    #endif
    px.xy = ((px.xy / px.w) - centerOffset) / scale; 
    py.xy = ((py.xy / py.w) - centerOffset) / scale; 
    pz.xy = ((pz.xy / pz.w) - centerOffset) / scale; 
    #ifdef INVERT_TEXTURE_V
        px.y = -px.y; py.y = -py.y; pz.y = -pz.y;
    #endif
    
    // Calculate dF/dx, dF/dy and dF/dz using chain rule
    vec4 dFdx = dFdu * px.x + dFdv * px.y;
    vec4 dFdy = dFdu * py.x + dFdv * py.y;
    vec4 dFdz = dFdu * pz.x + dFdv * pz.y;

    // Calculate the mean curvature
    float meanCurvature = ((dFdx.x + dFdy.y + dFdz.z) * 0.33333333333333333) * 100.0;
    outFragColor = vec4( (meanCurvature + 1.0) * 0.5);
    */
}
