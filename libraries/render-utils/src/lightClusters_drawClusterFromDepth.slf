<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//  lightClusters_drawClusterFro Depth.slf
//
//  Created by Sam Gateau on 9/8/2016.
//  Copyright 2015 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//


// Everything about deferred buffer
<@include DeferredBufferRead.slh@>


<@include LightClusterGrid.slh@>

<@include gpu/Color.slh@>
<$declareColorWheel()$>


in vec4 varTexCoord0;
out vec4 _fragColor;

void main(void) {

    // Grab the fragment data from the uv
    vec2 texCoord = varTexCoord0.st;

    float Zeye = texture(linearZeyeMap, texCoord).x;
    _fragColor = vec4(vec3(0.1 * (10 - Zeye)), 1.0);
  //  return;

    vec4 fragPosition = unpackDeferredPositionFromZeye(texCoord);


//    return;

    ivec3 dims = frustumGrid.dims.xyz;

    ivec3 summedDims = ivec3(dims.x * dims.y, dims.x, 1);


    vec3 eyePos = fragPosition.xyz;

   // vec4 worldPos = frustumGrid_eyeToWorld(vec4(eyePos.xyz, 1.0));

    ivec3 clusterPos = frustumGrid_eyeToClusterPos(eyePos);


    // standard transform
  //  TransformCamera cam = getTransformCamera();
   // <$transformWorldToClipPos(cam, worldPos, gl_Position)$>

    _fragColor = vec4(colorWheel(fract(float(clusterPos.z * summedDims.x + clusterPos.y * summedDims.y + clusterPos.x) / float(frustumGrid_numClusters()))), 0.9);
    _fragColor = vec4(abs(fract(eyePos * 0.5)), 0.9);

}

