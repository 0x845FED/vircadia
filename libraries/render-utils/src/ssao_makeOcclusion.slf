<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  ssao_makeOcclusion.frag
//
//  Created by Sam Gateau on 1/1/16.
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include ssao.slh@>
<$declareAmbientOcclusion()$>
<$declareFetchDepthPyramidMap()$>
<$declareSamplingDisk()$>
<$declareEvalObscurance()$>

<$declarePackOcclusionDepth()$>

#define SSAO_USE_HORIZON_BASED	1

layout(location=0) out vec4 outFragColor;

void main(void) {
    vec2 imageSize = getSideImageSize(getResolutionLevel());

    // Pixel being shaded
    vec2 fragCoord = gl_FragCoord.xy; 
    ivec2 centerPixelPos = ivec2(fragCoord.xy);

    // Fetch the z under the pixel (stereo or not)
    float Zeye = getZEyeAtPixel(centerPixelPos, 0);

    // Stereo side info
    ivec4 side = getStereoSideInfo(centerPixelPos.x, getResolutionLevel());

    // From now on, centerPixelPos is the pixel pos in the side
    centerPixelPos.x -= side.y;
    vec2 fragUVPos = (vec2(centerPixelPos) + vec2(0.5))  / imageSize;

    // The position  and normal of the pixel fragment in Eye space
    vec3 fragPositionES = evalEyePositionFromZeye(side.x, Zeye, fragUVPos);
    vec3 fragNormalES = evalEyeNormal(fragPositionES);

    // Choose the screen-space sample radius
    float ssDiskRadius = evalDiskRadius(fragPositionES.z, imageSize);
#if SSAO_USE_HORIZON_BASED
	ssDiskRadius = min(ssDiskRadius, 3.0);
#endif
    // Let's make noise 
    float randomPatternRotationAngle = getAngleDithering(centerPixelPos);

    // Accumulate the visibility for each samples
    float visibilitySum = 0.0;
    int numSamples = 1; // TEMPO OP getNumSamples()
    for (int i = 0; i < numSamples; ++i) {
#if SSAO_USE_HORIZON_BASED
		vec3 deltaTap = getUnitTapLocation(i, 1.0, randomPatternRotationAngle, PI);
        visibilitySum += evalVisibilityHBAO(side, centerPixelPos, imageSize, deltaTap.xy, ssDiskRadius, fragPositionES, fragNormalES);
#else
        vec3 tap = getTapLocationClampedSSAO(i, randomPatternRotationAngle, ssDiskRadius, centerPixelPos, imageSize);
        vec3 tapUVZ = fetchTap(side, centerPixelPos, tap, imageSize);
        vec3 tapPositionES = evalEyePositionFromZeye(side.x, tapUVZ.z, tapUVZ.xy);
        visibilitySum += float(tap.z > 0.0) * evalVisibilitySSAO(fragPositionES, fragNormalES, tapPositionES);
#endif
    }

#if SSAO_USE_HORIZON_BASED
    visibilitySum = 1.0 - visibilitySum * getInvNumSamples();
#else
    visibilitySum = visibilitySum * getInvNumSamples();
#endif
    float occlusion = clamp(1.0 - visibilitySum * getObscuranceScaling(), 0.0, 1.0);

     // KEEP IT for Debugging
    // Bilateral box-filter over a quad for free, respecting depth edges
    // (the difference that this makes is subtle)
/*    if (abs(dFdx(fragPositionES.z)) < 0.02) {
        occlusion -= dFdx(occlusion) * ((centerPixelPos.x & 1) - 0.5);
    }
    if (abs(dFdy(fragPositionES.z)) < 0.02) {
        occlusion -= dFdy(occlusion) * ((centerPixelPos.y & 1) - 0.5);
    }*/
    
    outFragColor = vec4(packOcclusionDepth(occlusion, CSZToDepthKey(fragPositionES.z)), 1.0);

}
