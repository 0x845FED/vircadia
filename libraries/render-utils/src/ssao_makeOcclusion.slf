<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  Created by Sam Gateau on 1/1/16.
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include ssao.slh@>
<$declareAmbientOcclusion()$>
<$declarePackOcclusionDepth()$>

const int NUM_SAMPLES = 11;
const float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);
const int NUM_SPIRAL_TURNS= 7;
const int LOG_MAX_OFFSET = 3;
const int MAX_MIP_LEVEL = 5;

// the depth pyramid texture
uniform sampler2D pyramidMap;

vec3 evalEyePosition(vec2 texcoord) {
    float Zeye = -texture(pyramidMap, texcoord, 0).x;
    return evalEyePositionFromZeye(Zeye, texcoord);
}

in vec2 varTexCoord0;
out vec4 outFragColor;

uniform sampler2D normalMap;

vec2 tapLocation(int sampleNumber, float spinAngle, out float ssR){
    // Radius relative to ssR
    float alpha = float(sampleNumber + 0.5) * INV_NUM_SAMPLES;
    float angle = alpha * (NUM_SPIRAL_TURNS * 6.28) + spinAngle;

    ssR = alpha;
    return vec2(cos(angle), sin(angle));
}

vec3 getOffsetPosition(ivec2 ssC, vec2 unitOffset, float ssR) {
    // Derivation:
    //  mipLevel = floor(log(ssR / MAX_OFFSET));
    int mipLevel = clamp(findMSB(int(ssR)) - LOG_MAX_OFFSET, 0, MAX_MIP_LEVEL);

    ivec2 ssP = ivec2(ssR * unitOffset) + ssC;

    vec3 P;

    // We need to divide by 2^mipLevel to read the appropriately scaled coordinate from a MIP-map.
    // Manually clamp to the texture size because texelFetch bypasses the texture unit
    ivec2 mipP = clamp(ssP >> mipLevel, ivec2(0), textureSize(pyramidMap, mipLevel) - ivec2(1));
    P.z = -texelFetch(pyramidMap, mipP, mipLevel).r;

    // Offset to pixel center
    //P = reconstructCSPosition(vec2(ssP) + vec2(0.5), P.z);

    vec2 tapUV = (vec2(ssP) + vec2(0.5)) / getWidthHeight();
    P = evalEyePositionFromZeye(P.z, tapUV);
    return P;
}

float sampleAO(in ivec2 ssC, in vec3 C, in vec3 n_C, in float ssDiskRadius, in int tapIndex, in float randomPatternRotationAngle) {
    // Offset on the unit disk, spun for this pixel
    float ssR;
    vec2 unitOffset = tapLocation(tapIndex, randomPatternRotationAngle, ssR);
    ssR *= ssDiskRadius;

    // The occluding point in camera space
    vec3 Q = getOffsetPosition(ssC, unitOffset, ssR);

    vec3 v = Q - C;
    float vv = dot(v, v);
    float vn = dot(v, n_C);

    const float bias =  0.01;
    const float epsilon = 0.01;
    float radius2 = getRadius2();

    // A: From the HPG12 paper
    // Note large epsilon to avoid overdarkening within cracks
    // return float(vv < radius2) * max((vn - bias) / (epsilon + vv), 0.0) * radius2 * 0.6;

    // B: Smoother transition to zero (lowers contrast, smoothing out corners). [Recommended]
    float f = max(radius2 - vv, 0.0);
    return f * f * f * max((vn - bias) / (epsilon + vv), 0.0);
}

vec3 debugValue(float f, float scale) {
    if (f < 0.0) {
        return vec3((scale + f) / scale, 0.0, 0.0);
    } else {
        return vec3(0.0, (scale - f) / scale, 0.0);
    }
}

void main(void) {
    // Pixel being shaded
    ivec2 ssC = ivec2(gl_FragCoord.xy);

    vec3 Cp = evalEyePosition(varTexCoord0);

    // Hash function used in the HPG12 AlchemyAO paper
    float randomPatternRotationAngle = (3 * ssC.x ^ ssC.y + ssC.x * ssC.y) * 10;

    vec3 Cn = evalEyeNormal(Cp);
   // vec3 Cn = normalize((texelFetch(normalMap, ssC, 0).xyz * 2.0) - vec3(1.0));

    // Choose the screen-space sample radius
    // proportional to the projected area of the sphere
    float ssDiskRadius = -getProjScale() * getRadius() / Cp.z;

    float sum = 0.0;
    for (int i = 0; i < NUM_SAMPLES; ++i) {
        sum += sampleAO(ssC, Cp, Cn, ssDiskRadius, i, randomPatternRotationAngle);
    }

    float A = max(0.0, 1.0 - sum * getObscuranceScaling() * 5.0 * INV_NUM_SAMPLES);

    // Bilateral box-filter over a quad for free, respecting depth edges
    // (the difference that this makes is subtle)
    if (abs(dFdx(Cp.z)) < 0.02) {
        A -= dFdx(A) * ((ssC.x & 1) - 0.5);
    }
    if (abs(dFdy(Cp.z)) < 0.02) {
        A -= dFdy(A) * ((ssC.y & 1) - 0.5);
    }

    outFragColor = vec4(packOcclusionDepth(A, CSZToDephtKey(Cp.z)), 1.0);
    //outFragColor = vec4(0.5 * (Cn + vec3(1.0)), A);
}
