<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  ssao_makeOcclusion.frag
//
//  Created by Sam Gateau on 1/1/16.
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include ssao.slh@>
<$declareAmbientOcclusion()$>
<$declareFetchDepthPyramidMap()$>
<$declareSamplingDisk()$>
<$declareEvalObscurance()$>

<$declarePackOcclusionDepth()$>

#define SSAO_HBAO_MAX_RADIUS    100.0

layout(location=0) out vec4 outFragColor;

void main(void) {
    // Pixel being shaded
    vec2 fragCoord = gl_FragCoord.xy; 
    ivec2 fragPixelPos = ivec2(fragCoord.xy);
#if SSAO_USE_QUAD_SPLIT
    ivec2 splitImageSize = ivec2(getOcclusionSplitSideSize());
    fragPixelPos = ((fragPixelPos - getPixelOffset()*splitImageSize) * 2) + getPixelOffset();
#endif

    // Fetch the z under the pixel (stereo or not)
    int depthTextureRatio = 1 << (getResolutionLevel() - getDepthResolutionLevel());
    ivec2 depthTexFragPixelPos = fragPixelPos * depthTextureRatio;
    float Zeye = getZEyeAtPixel(depthTexFragPixelPos, 0);
#if SSAO_USE_QUAD_SPLIT
    vec3 fragNormalES = getNormalEyeAtPixel(fragPixelPos, 0);
#endif

    // Stereo side info based on the real viewport size of this pass
    ivec2 sideOcclusionSize = ivec2( getOcclusionSideSize() );
    ivec4 side = getStereoSideInfoFromWidth(fragPixelPos.x, sideOcclusionSize.x);

    // From now on, fragPixelPos is the pixel pos in the side
    vec2 depthSideSize = getDepthTextureSideSize(0);
    vec2 sideImageSize = depthSideSize / float(depthTextureRatio);
    fragPixelPos.x -= side.y;
    vec2 fragUVPos = (vec2(fragPixelPos) + vec2(0.5))  / sideImageSize;

    // The position and normal of the pixel fragment in Eye space
    vec3 fragPositionES = evalEyePositionFromZeye(side.x, Zeye, fragUVPos);
#if !SSAO_USE_QUAD_SPLIT
    vec3 fragNormalES = buildNormal(side, fragUVPos, depthTexFragPixelPos, fragPositionES, depthSideSize);
#endif

    // Choose the screen-space sample radius
    float diskPixelRadius = evalDiskRadius(fragPositionES.z, sideImageSize);
#if SSAO_USE_HORIZON_BASED
    diskPixelRadius = min(diskPixelRadius, SSAO_HBAO_MAX_RADIUS);
#endif

    // Let's make noise 
    float randomPatternRotationAngle = getAngleDithering(fragPixelPos);

    // Accumulate the obscurance for each samples
    float obscuranceSum = 0.0;
    int numSamples = int(getNumSamples());
    float invNumSamples = getInvNumSamples();

    // Steps are in the depth texture resolution
    depthTexFragPixelPos = fragPixelPos * depthTextureRatio;
    for (int i = 0; i < numSamples; ++i) {
#if SSAO_USE_HORIZON_BASED
		vec3 deltaTap = getUnitTapLocation(i, 1.0, randomPatternRotationAngle, PI);
        obscuranceSum += evalVisibilityHBAO(side, vec2(depthTexFragPixelPos), depthSideSize, deltaTap.xy, diskPixelRadius, fragPositionES, fragNormalES);
#else
        vec3 tap = getTapLocationClampedSSAO(i, randomPatternRotationAngle, diskPixelRadius, depthTexFragPixelPos, depthSideSize);
        vec2 tapPixelPos = vec2(depthTexFragPixelPos) + tap.xy;
        vec3 tapUVZ = fetchTap(side, tapPixelPos, tap.z, depthSideSize);
        vec3 tapPositionES = evalEyePositionFromZeye(side.x, tapUVZ.z, tapUVZ.xy);
        obscuranceSum += float(tap.z > 0.0) * evalVisibilitySSAO(fragPositionES, fragNormalES, tapPositionES);
#endif
    }

#if SSAO_USE_HORIZON_BASED
    obscuranceSum *= 0.5 / PI;
#endif

    float occlusion = clamp(1.0 - obscuranceSum * getObscuranceScaling() * invNumSamples, 0.0, 1.0);
    
    outFragColor = vec4(vec3(occlusion), 1.0);
}
