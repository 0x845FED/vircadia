<!
//  DeferredBuffer.slh
//  libraries/render-utils/src
//
//  Created by Sam Gateau on 1/12/15.
//  Copyright 2013 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
!>
<@if not DEFERRED_BUFFER_SLH@>
<@def DEFERRED_BUFFER_SLH@>

uniform bool stereoMode = false;

// the diffuse texture
uniform sampler2D diffuseMap;

// the normal texture
uniform sampler2D normalMap;

// the specular texture
uniform sampler2D specularMap;

// the depth texture
uniform sampler2D depthMap;


struct DeferredTransform { 
    mat4 view;
    mat4 viewInverse;

    // the distance to the near clip plane
    // scale factor for depth: (far - near) / far
    vec4 nearVal_depthScale_spareAB;
    // offset for depth texture coordinates
    // scale for depth texture coordinates
    vec4 depthTexCoordOffset_scale;

};

layout(std140) uniform deferredTransformBuffer {
    DeferredTransform _deferredTransform;
};
DeferredTransform getDeferredTransform() {
    return _deferredTransform;
}

vec4 evalEyePositionFromZ(DeferredTransform deferredTransform, float depthVal, vec2 texcoord) {
    vec2 nearVal_depthScale = deferredTransform.nearVal_depthScale_spareAB.xy;
    vec2 depthTexCoordOffset = deferredTransform.depthTexCoordOffset_scale.xy;
    vec2 depthTexCoordScale = deferredTransform.depthTexCoordOffset_scale.zw;

    // compute the view space position using the depth
    float z = nearVal_depthScale.x / (depthVal * nearVal_depthScale.y - 1.0);
    return vec4((depthTexCoordOffset + texcoord * depthTexCoordScale) * z, z, 1.0);
}

struct DeferredFragment {
    float depthVal;
    vec4 normalVal;
    vec4 diffuseVal;
    vec4 specularVal;
    vec4 position;
    vec3 normal;
    vec3 diffuse;
    float opacity;
    vec3 specular;
    float gloss;
};

DeferredFragment unpackDeferredFragment( vec2 texcoord) {
    
    DeferredTransform deferredTransform = getDeferredTransform();

    DeferredFragment frag;
    frag.depthVal = texture(depthMap, texcoord).r;
    frag.normalVal = texture(normalMap, texcoord);
    frag.diffuseVal = texture(diffuseMap, texcoord);
    frag.specularVal = texture(specularMap, texcoord);

    if (stereoMode) {
        if (texcoord.x > 0.5) {
            texcoord.x -= 0.5;
        }
        texcoord.x *= 2.0;
    }

    frag.position = evalEyePositionFromZ(deferredTransform, frag.depthVal, texcoord);

    // compute the view space position using the depth
  /*  float z = near / (frag.depthVal * depthScale - 1.0);
    frag.position = vec4((depthTexCoordOffset + texcoord * depthTexCoordScale) * z, z, 1.0);
    */
   // Unpack the normal from the map
    frag.normal = normalize(frag.normalVal.xyz * 2.0 - vec3(1.0));

    frag.diffuse = frag.diffuseVal.xyz;
    frag.opacity = frag.diffuseVal.w;
    frag.specular = frag.specularVal.xyz;
    frag.gloss = frag.specularVal.w;

    return frag;
}


<@endif@>
