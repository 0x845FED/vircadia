<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  model_translucent.frag
//  fragment shader
//
//  Created by Andrzej Kapolka on 9/19/14.
//  Copyright 2014 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//
<!/*<@include DeferredBufferWrite.slh@>

<@include model/Material.slh@>

// the diffuse texture
uniform sampler2D diffuseMap;

varying vec4 interpolatedNormal;

varying vec3 color;

void main(void) {

    // Fetch diffuse map
    vec4 diffuse = texture2D(diffuseMap, gl_TexCoord[0].st);

    Material mat = getMaterial();

    packDeferredFragmentTranslucent(
        normalize(interpolatedNormal.xyz),
        getMaterialOpacity(mat) * diffuse.a,
        getMaterialDiffuse(mat) * diffuse.rgb * color,
        getMaterialSpecular(mat),
        getMaterialShininess(mat));

    // set the diffuse data
 //   gl_FragData[0] = gl_Color * texture2D(diffuseMap, gl_TexCoord[0].st);
}*/!>
<@include model/Material.slh@>

// Everything about global lighting

<@include DeferredLighting.slh@>
<@include gpu/Transform.slh@>
<$declareStandardTransform()$>


// Everything about light
<@include model/Light.slh@>

// The view Matrix
//uniform mat4 invViewMat;

vec3 evalAmbienGlobalColor(float shadowAttenuation, vec3 position, vec3 normal, vec3 diffuse, vec3 specular, float gloss) {

    // Need the light now
    Light light = getLight();
    TransformCamera cam = getTransformCamera();
    mat4 invViewMat = cam._viewInverse;

    vec3 fragNormal = vec3(invViewMat * vec4(normal, 0.0));
    vec4 fragEyeVector = invViewMat * vec4(-position, 0.0);
    vec3 fragEyeDir = normalize(fragEyeVector.xyz);

    vec3 color = diffuse.rgb * getLightColor(light) * getLightAmbientIntensity(light);

    vec4 shading = evalFragShading(fragNormal, -getLightDirection(light), fragEyeDir, specular, gloss);

    color += vec3(diffuse + shading.rgb) * shading.w * shadowAttenuation * getLightColor(light) * getLightIntensity(light);

    return color;
}

// the diffuse texture
uniform sampler2D diffuseMap;

// the interpolated view position
varying vec4 interpolatedPosition;

// the interpolated normal
varying vec4 interpolatedNormal;

varying vec3 color;

void main(void) {
    vec3 fragPosition = interpolatedPosition.xyz;

    // Fetch diffuse map
    vec4 diffuse = texture2D(diffuseMap, gl_TexCoord[0].st);

    Material mat = getMaterial();
    vec3 fragNormal = normalize(interpolatedNormal.xyz);
    float fragOpacity = getMaterialOpacity(mat) * diffuse.a;
    vec3 fragDiffuse = getMaterialDiffuse(mat) * diffuse.rgb * color;
    vec3 fragSpecular = getMaterialSpecular(mat);
    float fragGloss = getMaterialShininess(mat);

    vec3 color =  evalAmbienGlobalColor(1.0,
                                    fragPosition,
                                    fragNormal,
                                    fragDiffuse,
                                    fragSpecular,
                                    fragGloss);

    gl_FragColor = vec4(color, fragOpacity);
}
