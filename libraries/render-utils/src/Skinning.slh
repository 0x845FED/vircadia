<!
//  Skinning.slh
//  libraries/render-utils/src
//
//  Created by Sam Gateau on 10/5/15.
//  Copyright 2013 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
!>
<@if not SKINNING_SLH@>
<@def SKINNING_SLH@>

const int MAX_CLUSTERS = 128;
const int INDICES_PER_VERTEX = 4;

layout(std140) uniform skinClusterBuffer {
    mat4 clusterMatrices[MAX_CLUSTERS];
};

vec4 quatConj(vec4 v) {
    return vec4(-v.x, -v.y, -v.z, v.w);
}

vec4 quatMul(vec4 q1, vec4 q2) {
    return vec4( q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x,
                -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y,
                 q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z,
                -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);
}

vec3 rotateByQuat(vec4 q, vec3 p) {
    return vec3(quatMul(quatMul(q, vec4(p.x, p.y, p.z, 0.0)), quatConj(q)));
}

void dqMul(vec4 lhsReal, vec4 lhsImag, vec4 rhsReal, vec4 rhsImag, out vec4 realOut, out vec4 imagOut) {
    realOut = quatMul(lhsReal, rhsReal);
    imagOut = quatMul(lhsReal, rhsImag) + quatMul(lhsImag, rhsReal);
}

void skinPosition(ivec4 skinClusterIndex, vec4 skinClusterWeight, vec4 inPosition, out vec4 skinnedPosition) {
    vec3 sAccum = vec3(0.0, 0.0, 0.0);
    vec4 rAccum = vec4(0.0, 0.0, 0.0, 0.0);
    vec3 tAccum = vec3(0.0, 0.0, 0.0);

    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        mat4 clusterMatrix = clusterMatrices[(skinClusterIndex[i])];
        float clusterWeight = skinClusterWeight[i];

        vec3 s = vec3(clusterMatrix[0][0], clusterMatrix[0][1], clusterMatrix[0][2]);
        vec4 r = vec4(clusterMatrix[1][0], clusterMatrix[1][1], clusterMatrix[1][2], clusterMatrix[1][3]);
        vec3 t = vec3(clusterMatrix[2][0], clusterMatrix[2][1], clusterMatrix[2][2]);

        if (dot(r, rAccum) < 0) {
            r = -r;
        }

        sAccum += s * clusterWeight;
        rAccum += r * clusterWeight;
        tAccum += t * clusterWeight;
    }

    rAccum = normalize(rAccum);

    skinnedPosition = vec4(rotateByQuat(rAccum, (vec3(inPosition) * sAccum)) + tAccum, 1);
}

void skinPositionNormal(ivec4 skinClusterIndex, vec4 skinClusterWeight, vec4 inPosition, vec3 inNormal,
                        out vec4 skinnedPosition, out vec3 skinnedNormal) {

    vec3 sAccum = vec3(0.0, 0.0, 0.0);
    vec4 rAccum = vec4(0.0, 0.0, 0.0, 0.0);
    vec3 tAccum = vec3(0.0, 0.0, 0.0);

    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        mat4 clusterMatrix = clusterMatrices[(skinClusterIndex[i])];
        float clusterWeight = skinClusterWeight[i];

        vec3 s = vec3(clusterMatrix[0][0], clusterMatrix[0][1], clusterMatrix[0][2]);
        vec4 r = vec4(clusterMatrix[1][0], clusterMatrix[1][1], clusterMatrix[1][2], clusterMatrix[1][3]);
        vec3 t = vec3(clusterMatrix[2][0], clusterMatrix[2][1], clusterMatrix[2][2]);

        if (dot(r, rAccum) < 0) {
            r = -r;
        }

        sAccum += s * clusterWeight;
        rAccum += r * clusterWeight;
        tAccum += t * clusterWeight;
    }

    rAccum = normalize(rAccum);

    skinnedPosition = vec4(rotateByQuat(rAccum, (vec3(inPosition) * sAccum)) + tAccum, 1);
    skinnedNormal = rotateByQuat(rAccum, inNormal);
}

void skinPositionNormalTangent(ivec4 skinClusterIndex, vec4 skinClusterWeight, vec4 inPosition, vec3 inNormal, vec3 inTangent,
                               out vec4 skinnedPosition, out vec3 skinnedNormal, out vec3 skinnedTangent) {

    vec3 sAccum = vec3(0.0, 0.0, 0.0);
    vec4 rAccum = vec4(0.0, 0.0, 0.0, 0.0);
    vec3 tAccum = vec3(0.0, 0.0, 0.0);

    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        mat4 clusterMatrix = clusterMatrices[(skinClusterIndex[i])];
        float clusterWeight = skinClusterWeight[i];

        vec3 s = vec3(clusterMatrix[0][0], clusterMatrix[0][1], clusterMatrix[0][2]);
        vec4 r = vec4(clusterMatrix[1][0], clusterMatrix[1][1], clusterMatrix[1][2], clusterMatrix[1][3]);
        vec3 t = vec3(clusterMatrix[2][0], clusterMatrix[2][1], clusterMatrix[2][2]);

        if (dot(r, rAccum) < 0) {
            r = -r;
        }

        sAccum += s * clusterWeight;
        rAccum += r * clusterWeight;
        tAccum += t * clusterWeight;
    }

    rAccum = normalize(rAccum);

    skinnedPosition = vec4(rotateByQuat(rAccum, (vec3(inPosition) * sAccum)) + tAccum, 1);
    skinnedNormal = rotateByQuat(rAccum, inNormal);
    skinnedTangent = rotateByQuat(rAccum, inTangent);
}

/*
// ORIGINAL
void skinPosition(ivec4 skinClusterIndex, vec4 skinClusterWeight, vec4 inPosition, out vec4 skinnedPosition) {
    vec4 newPosition = vec4(0.0, 0.0, 0.0, 0.0);

    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        mat4 clusterMatrix = clusterMatrices[(skinClusterIndex[i])];
        float clusterWeight = skinClusterWeight[i];
        newPosition += clusterMatrix * inPosition * clusterWeight;
    }

    skinnedPosition = newPosition;
}

void skinPositionNormal(ivec4 skinClusterIndex, vec4 skinClusterWeight, vec4 inPosition, vec3 inNormal,
                        out vec4 skinnedPosition, out vec3 skinnedNormal) {
    vec4 newPosition = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 newNormal = vec4(0.0, 0.0, 0.0, 0.0);

    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        mat4 clusterMatrix = clusterMatrices[(skinClusterIndex[i])];
        float clusterWeight = skinClusterWeight[i];
        newPosition += clusterMatrix * inPosition * clusterWeight;
        newNormal += clusterMatrix * vec4(inNormal.xyz, 0.0) * clusterWeight;
    }

    skinnedPosition = newPosition;
    skinnedNormal = newNormal.xyz;
}

void skinPositionNormalTangent(ivec4 skinClusterIndex, vec4 skinClusterWeight, vec4 inPosition, vec3 inNormal, vec3 inTangent,
                               out vec4 skinnedPosition, out vec3 skinnedNormal, out vec3 skinnedTangent) {
    vec4 newPosition = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 newNormal = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 newTangent = vec4(0.0, 0.0, 0.0, 0.0);

    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        mat4 clusterMatrix = clusterMatrices[(skinClusterIndex[i])];
        float clusterWeight = skinClusterWeight[i];
        newPosition += clusterMatrix * inPosition * clusterWeight;
        newNormal += clusterMatrix * vec4(inNormal.xyz, 0.0) * clusterWeight;
        newTangent += clusterMatrix * vec4(inTangent.xyz, 0.0) * clusterWeight;
    }

    skinnedPosition = newPosition;
    skinnedNormal = newNormal.xyz;
    skinnedTangent = newTangent.xyz;
}
*/

<@endif@>
