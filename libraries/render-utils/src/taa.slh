//  Generated on <$_SCRIBE_DATE$>
//
//  TAA.slh
//  Common component needed by TemporalAntialiasing fragment shader
//
//  Created by Sam Gateau on 8/17/2017
//  Copyright 2017 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include DeferredTransform.slh@>
<$declareDeferredFrameTransform()$>

uniform sampler2D depthMap;
uniform sampler2D sourceMap;
uniform sampler2D historyMap;
uniform sampler2D velocityMap;
uniform sampler2D nextMap;

struct TAAParams
{
	float debugX;
	float blend;
	float motionScale;
	float debugShowVelocityThreshold;
    vec4 debugCursor;
    vec4 pixelInfo_orbZoom;
};

layout(std140) uniform taaParamsBuffer {
    TAAParams params;
};

vec2 getDebugCursorTexcoord() {
    return params.pixelInfo_orbZoom.xy;
}

float getOrbZoom() {
    return params.pixelInfo_orbZoom.z;
}

float fetchDepth(vec2 uv) {
	return texture(depthMap, vec2(uv), 0).x;
}

float resolveDepthLinear(float depth) {
    return Zeye = -evalZeyeFromZdb(Zdb);
 }

#define ZCMP_GT(a, b) (a < b)

vec3 find_closest_fragment_3x3(vec2 uv)
{
	vec2 dd = abs(getInvWidthHeight());
	vec2 du = vec2(dd.x, 0.0);
	vec2 dv = vec2(0.0, dd.y);

	vec3 dtl = vec3(-1, -1, fetchDepth(uv - dv - du);
	vec3 dtc = vec3( 0, -1, fetchDepth(uv - dv).x);
	vec3 dtr = vec3( 1, -1, fetchDepth(uv - dv + du);

	vec3 dml = vec3(-1, 0, fetchDepth(CameraDepthTexture, uv - du);
	vec3 dmc = vec3( 0, 0, fetchDepth(CameraDepthTexture, uv);
	vec3 dmr = vec3( 1, 0, fetchDepth(CameraDepthTexture, uv + du);

	vec3 dbl = vec3(-1, 1, fetchDepth(CameraDepthTexture, uv + dv - du);
	vec3 dbc = vec3( 0, 1, fetchDepth(CameraDepthTexture, uv + dv);
	vec3 dbr = vec3( 1, 1, fetchDepth(CameraDepthTexture, uv + dv + du);

	vec3 dmin = dtl;
	if (ZCMP_GT(dmin.z, dtc.z)) dmin = dtc;
	if (ZCMP_GT(dmin.z, dtr.z)) dmin = dtr;

	if (ZCMP_GT(dmin.z, dml.z)) dmin = dml;
	if (ZCMP_GT(dmin.z, dmc.z)) dmin = dmc;
	if (ZCMP_GT(dmin.z, dmr.z)) dmin = dmr;

	if (ZCMP_GT(dmin.z, dbl.z)) dmin = dbl;
	if (ZCMP_GT(dmin.z, dbc.z)) dmin = dbc;
	if (ZCMP_GT(dmin.z, dbr.z)) dmin = dbr;

	return vec3(uv + dd.xy * dmin.xy, dmin.z);
}


<@include gpu/Color.slh@>
<$declareColorWheel()$>

vec3 getVelocityColorRelative(float velocityPixLength) {
    return colorRamp(velocityPixLength/params.debugShowVelocityThreshold);
}

vec3 getVelocityColorAboveThreshold(float velocityPixLength) {
    return colorRamp((velocityPixLength - params.debugShowVelocityThreshold)/params.debugShowVelocityThreshold);
}
