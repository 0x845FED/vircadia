//  Generated on <$_SCRIBE_DATE$>
//
//  TAA.slh
//  Common component needed by TemporalAntialiasing fragment shader
//
//  Created by Sam Gateau on 8/17/2017
//  Copyright 2017 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include DeferredTransform.slh@>
<$declareDeferredFrameTransform()$>

const int SEQUENCE_LENGTH = 16;
const int INFO_INDEX = SEQUENCE_LENGTH / 2;
struct JitterSequence {
    vec4 offsets[INFO_INDEX + 1];
};
layout(std140) uniform taaJitterBuffer {
    JitterSequence sequence;
};

vec2 taa_getJitterSample(int index) {
    return vec2((bool(index & 0x01) ? sequence.offsets[index >> 1].zw : sequence.offsets[index >> 1].xy));
}

int taa_getJitterSequenceLength() {
    return floatBitsToInt(sequence.offsets[INFO_INDEX].z);
}

int taa_getCurrentJitterIndex() {
    return floatBitsToInt(sequence.offsets[INFO_INDEX].w);
}

vec2 taa_getCurrentJitterSample() {
    return taa_getJitterSample(taa_getCurrentJitterIndex());
}

<@include gpu/Color.slh@>

uniform sampler2D depthMap;
uniform sampler2D sourceMap;
uniform sampler2D historyMap;
uniform sampler2D velocityMap;
uniform sampler2D nextMap;

struct TAAParams
{
	float none;
	float blend;
	float motionScale;
	float debugShowVelocityThreshold;
    ivec4 flags;
    vec4 pixelInfo_orbZoom;
    vec4 regionInfo;
};

layout(std140) uniform taaParamsBuffer {
    TAAParams params;
};

#define GET_BIT(bitfield, bitIndex) bool((bitfield) & (1 << (bitIndex)))

bool taa_showDebugCursor() {
    return GET_BIT(params.flags.x, 1);
}

bool taa_showJitterSequence() {
    return GET_BIT(params.flags.x, 2);
}

bool taa_showClosestFragment() {
    return GET_BIT(params.flags.x, 3);
}


bool taa_unjitter() {
    return GET_BIT(params.flags.y, 0);
}
bool taa_constrainColor() {
    return GET_BIT(params.flags.y, 1);
}

vec2 taa_getDebugCursorTexcoord() {
    return params.pixelInfo_orbZoom.xy;
}

float taa_getDebugOrbZoom() {
    return params.pixelInfo_orbZoom.z;
}

vec2 taa_getRegionDebug() {
    return params.regionInfo.xy;
}

vec2 taa_getRegionFXAA() {
    return params.regionInfo.zw;
}

vec4 taa_fetchColor(sampler2D map, vec2 uv) {
#if USE_YCOCG
		vec4 c = texture(map, uv);
		return vec4(color_LinearToYCoCg(c.rgb), c.a);
#else
		return texture(map, uv);
#endif
}

vec3 taa_resolveColor(vec3 color) {
#if USE_YCOCG
		return color_YCoCgToLinear(color);
#else
		return color;
#endif
}

vec4 taa_fetchSourceMap(vec2 uv) {
#if USE_YCOCG
		vec4 c = texture(sourceMap, uv);
		return vec4(color_LinearToYCoCg(c.rgb), c.a);
#else
		return texture(sourceMap, uv);
#endif
}

vec4 taa_fetchHistoryMap(vec2 uv) {
#if USE_YCOCG
		vec4 c = texture(historyMap, uv);
		return vec4(color_LinearToYCoCg(c.rgb), c.a);
#else
		return texture(historyMap, uv);
#endif
}

vec4 taa_fetchNextMap(vec2 uv) {
#if USE_YCOCG
		vec4 c = texture(nextMap, uv);
		return vec4(color_LinearToYCoCg(c.rgb), c.a);
#else
		return texture(nextMap, uv);
#endif
}

vec2 taa_fetchVelocityMap(vec2 uv) {
	return texture(velocityMap, uv).xy;
}

float taa_fetchDepth(vec2 uv) {
	return -texture(depthMap, vec2(uv), 0).x;
}


#define ZCMP_GT(a, b) (a > b)

vec3 taa_findClosestFragment3x3(vec2 uv)
{
	vec2 dd = abs(getInvWidthHeight());
	vec2 du = vec2(dd.x, 0.0);
	vec2 dv = vec2(0.0, dd.y);

	vec3 dtl = vec3(-1, -1, taa_fetchDepth(uv - dv - du));
	vec3 dtc = vec3( 0, -1, taa_fetchDepth(uv - dv));
	vec3 dtr = vec3( 1, -1, taa_fetchDepth(uv - dv + du));

	vec3 dml = vec3(-1, 0, taa_fetchDepth(uv - du));
	vec3 dmc = vec3( 0, 0, taa_fetchDepth(uv));
	vec3 dmr = vec3( 1, 0, taa_fetchDepth(uv + du));

	vec3 dbl = vec3(-1, 1, taa_fetchDepth(uv + dv - du));
	vec3 dbc = vec3( 0, 1, taa_fetchDepth(uv + dv));
	vec3 dbr = vec3( 1, 1, taa_fetchDepth(uv + dv + du));

	vec3 dmin = dtl;
	if (ZCMP_GT(dmin.z, dtc.z)) dmin = dtc;
	if (ZCMP_GT(dmin.z, dtr.z)) dmin = dtr;

	if (ZCMP_GT(dmin.z, dml.z)) dmin = dml;
	if (ZCMP_GT(dmin.z, dmc.z)) dmin = dmc;
	if (ZCMP_GT(dmin.z, dmr.z)) dmin = dmr;

	if (ZCMP_GT(dmin.z, dbl.z)) dmin = dbl;
	if (ZCMP_GT(dmin.z, dbc.z)) dmin = dbc;
	if (ZCMP_GT(dmin.z, dbr.z)) dmin = dbr;

	return vec3(uv + dd.xy * dmin.xy, dmin.z);
}

vec2 taa_fetchSourceAndHistory(vec2 fragUV, vec2 fragVelocity, out vec3 sourceColor, out vec3 historyColor) {
    sourceColor = taa_fetchSourceMap(fragUV).xyz;

    vec2 prevFragUV = fragUV - fragVelocity;
    historyColor = sourceColor;
    if (!(any(lessThan(prevFragUV, vec2(0.0))) || any(greaterThan(prevFragUV, vec2(1.0))))) {
        historyColor = taa_fetchHistoryMap(prevFragUV).xyz;
    }
    return prevFragUV;
}

float Luminance(vec3 rgb) {
    return rgb.x/4.0 + rgb.y/2.0 + rgb.z/4.0;
}

vec3 taa_temporalReprojection(vec3 sourceColor, vec3 historyColor, vec2 fragUV, vec2 fragVelocity, float fragZe, vec2 fragJitterPix)
{
    vec4 texel1 = vec4(historyColor, 1.0);
    vec4 texel0 = vec4(sourceColor, 1.0);

    vec2 imageSize = getWidthHeight(0);
    vec2 texelSize = getInvWidthHeight();

  /*  if (taa_unjitter()) {
        fragUV += fragJitterPix * texelSize;
    }*/

		const float _SubpixelThreshold = 0.5;
		const float _GatherBase = 0.5;
		const float _GatherSubpixelMotion = 0.1666;
        const float _FeedbackMin = 0.1;
        const float _FeedbackMax = 0.9;

		vec2 texel_vel = fragVelocity * imageSize;
		float texel_vel_mag = length(texel_vel) * -fragZe;
		float k_subpixel_motion = clamp(_SubpixelThreshold / (0.0001 + texel_vel_mag), 0.0, 1.0);
		float k_min_max_support = _GatherBase + _GatherSubpixelMotion * k_subpixel_motion;

		vec2 ss_offset01 = k_min_max_support * vec2(-texelSize.x, texelSize.y);
		vec2 ss_offset11 = k_min_max_support * vec2(texelSize.x, texelSize.y);
		vec4 c00 = taa_fetchSourceMap(fragUV - ss_offset11);
		vec4 c10 = taa_fetchSourceMap(fragUV - ss_offset01);
		vec4 c01 = taa_fetchSourceMap(fragUV + ss_offset01);
		vec4 c11 = taa_fetchSourceMap(fragUV + ss_offset11);

		vec4 cmin = min(c00, min(c10, min(c01, c11)));
		vec4 cmax = max(c00, max(c10, max(c01, c11)));

		#if USE_YCOCG || USE_CLIPPING
			vec4 cavg = (c00 + c10 + c01 + c11) / 4.0;
		#endif


		// shrink chroma min-max
	#if USE_YCOCG
		vec2 chroma_extent = 0.25 * 0.5 * (cmax.r - cmin.r);
		vec2 chroma_center = texel0.gb;
		cmin.yz = chroma_center - chroma_extent;
		cmax.yz = chroma_center + chroma_extent;
		cavg.yz = chroma_center;
	#endif

		// clamp to neighbourhood of current sample
	#if USE_CLIPPING
		texel1 = clip_aabb(cmin.xyz, cmax.xyz, clamp(cavg, cmin, cmax), texel1);
	#else
		texel1 = clamp(texel1, cmin, cmax);
	#endif

		// feedback weight from unbiased luminance diff (t.lottes)
	#if USE_YCOCG
		float lum0 = texel0.r;
		float lum1 = texel1.r;
	#else
		float lum0 = Luminance(texel0.rgb);
		float lum1 = Luminance(texel1.rgb);
	#endif
		float unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));
		float unbiased_weight = 1.0 - unbiased_diff;
		float unbiased_weight_sqr = unbiased_weight * unbiased_weight;
		float k_feedback = mix(_FeedbackMin, _FeedbackMax, unbiased_weight_sqr);

		// output
    vec3 nextColor =  mix(texel0, texel1, k_feedback).xyz;

    return taa_resolveColor(nextColor);
}

<$declareColorWheel()$>

vec3 taa_getVelocityColorRelative(float velocityPixLength) {
    return colorRamp(velocityPixLength/params.debugShowVelocityThreshold);
}

vec3 taa_getVelocityColorAboveThreshold(float velocityPixLength) {
    return colorRamp((velocityPixLength - params.debugShowVelocityThreshold)/params.debugShowVelocityThreshold);
}


vec3 taa_evalTXAA(vec2 fragUV) {

    vec2 texelSize = getInvWidthHeight();

    // filter width limit for dependent "two-tap" texture samples
    float FXAA_SPAN_MAX = 8.0;

    // local contrast multiplier for performing AA
    // higher = sharper, but setting this value too high will cause near-vertical and near-horizontal edges to fail
    // see "fxaaQualityEdgeThreshold"
    float FXAA_REDUCE_MUL = 1.0 / 8.0;

    // luminance threshold for processing dark colors
    // see "fxaaQualityEdgeThresholdMin"
    float FXAA_REDUCE_MIN = 1.0 / 128.0;

    // fetch raw RGB values for nearby locations
    // sampling pattern is "five on a die" (each diagonal direction and the center)
    // computing the coordinates for these texture reads could be moved to the vertex shader for speed if needed
    vec3 rgbNW = texture(sourceMap, fragUV + (vec2(-1.0, -1.0) * texelSize)).xyz;
    vec3 rgbNE = texture(sourceMap, fragUV + (vec2(+1.0, -1.0) * texelSize)).xyz;
    vec3 rgbSW = texture(sourceMap, fragUV + (vec2(-1.0, +1.0) * texelSize)).xyz;
    vec3 rgbSE = texture(sourceMap, fragUV + (vec2(+1.0, +1.0) * texelSize)).xyz;
    vec3 rgbM  = texture(sourceMap, fragUV).xyz;
	
    // convert RGB values to luminance
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot( rgbM, luma);
	
    // luma range of local neighborhood
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
	
    // direction perpendicular to local luma gradient
    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    // compute clamped direction offset for additional "two-tap" samples
    // longer vector = blurry, shorter vector = sharp
    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX,  FXAA_SPAN_MAX), 
          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * texelSize;
		
    // perform additional texture sampling perpendicular to gradient
    vec3 rgbA = (1.0 / 2.0) * (
                texture(sourceMap, fragUV + dir * (1.0 / 3.0 - 0.5)).xyz +
                texture(sourceMap, fragUV + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * (1.0 / 2.0) + (1.0 / 4.0) * (
                texture(sourceMap, fragUV + dir * (0.0 / 3.0 - 0.5)).xyz +
                texture(sourceMap, fragUV + dir * (3.0 / 3.0 - 0.5)).xyz);
    float lumaB = dot(rgbB, luma);

    // compare luma of new samples to the luma range of the original neighborhood
    // if the new samples exceed this range, just use the first two samples instead of all four
    if (lumaB < lumaMin || lumaB > lumaMax) {
        return rgbA;
    } else {
        return rgbB;
    }
}