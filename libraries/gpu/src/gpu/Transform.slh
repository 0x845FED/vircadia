<!
//  gpu/TransformState.slh
//
//  Created by Sam Gateau on 2/10/15.
//  Copyright 2013 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
!>
<@if not GPU_TRANSFORM_STATE_SLH@>
<@def GPU_TRANSFORM_STATE_SLH@>

struct TransformObject { 
    mat4 _model;
    mat4 _modelInverse;
};

struct TransformCamera { 
    mat4 _projection;
    mat4 _view;
    mat4 _viewInverse;
    mat4 _projectionViewUntranslated;
};

vec4 transform(TransformCamera camera, TransformObject object, vec4 pos) {
  /*  vec4 res = object._model * pos;
    res += pos.w * camera._viewInverse[3];
    return camera._projectionViewUntranslated * res;
*/
    return camera._projectionViewUntranslated * object._model * pos;
  //  return camera._projection * camera._view * object._model * pos;
}

vec3 transformDir(TransformCamera camera, TransformObject object, vec3 dir) {
    vec3 mIr0 = vec3(object._modelInverse[0].x, object._modelInverse[1].x, object._modelInverse[2].x);
    vec3 mIr1 = vec3(object._modelInverse[0].y, object._modelInverse[1].y, object._modelInverse[2].y);
    vec3 mIr2 = vec3(object._modelInverse[0].z, object._modelInverse[1].z, object._modelInverse[2].z);

    vec3 mvIc0 = vec3(dot(camera._viewInverse[0].xyz, mIr0), dot(camera._viewInverse[0].xyz, mIr1), dot(camera._viewInverse[0].xyz, mIr2));
    vec3 mvIc1 = vec3(dot(camera._viewInverse[1].xyz, mIr0), dot(camera._viewInverse[1].xyz, mIr1), dot(camera._viewInverse[1].xyz, mIr2));
    vec3 mvIc2 = vec3(dot(camera._viewInverse[2].xyz, mIr0), dot(camera._viewInverse[2].xyz, mIr1), dot(camera._viewInverse[2].xyz, mIr2));

    vec3 result = vec3(dot(mvIc0, dir),
                       dot(mvIc1, dir),
                       dot(mvIc2, dir));
                        
    return result;
}

<@if GLPROFILE == PC_GL@>
uniform transformObjectBuffer {
    TransformObject object;
};
TransformObject getTransformObject() {
    return object;
}

uniform transformCameraBuffer {
    TransformCamera camera;
};
TransformCamera getTransformCamera() {
    return camera;
}
<@elif GLPROFILE == MAC_GL@>
uniform vec4 transformStateBuffer[2];
TransformState getTransformState() {
    TransformState xform;
    xform._diffuse = transformStateBuffer[0];
    xform._specular = transformStateBuffer[1];
    return xform;
}
<@else@>
uniform vec4 transformStateBuffer[2];
TransformState getMaterial() {
    TransformState xform;
    xform._diffuse = transformStateBuffer[0];
    xform._specular = transformStateBuffer[1];
    return xform;   
}
<@endif@>


<@endif@>
