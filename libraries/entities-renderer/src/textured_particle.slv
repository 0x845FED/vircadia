<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on <$_SCRIBE_DATE$>
//
//  particle vertex shader
//
//  Copyright 2015 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include gpu/Transform.slh@>

<$declareStandardTransform()$>

struct ParticleUniforms {
    struct {
        float start;
        float middle;
        float finish;
        float spread;
    } radius;
    
    struct {
        vec4 start;
        vec4 middle;
        vec4 finish;
        vec4 spread;
    } color;
    
    float lifespan;
};

uniform particleBuffer {
    ParticleUniforms particle;
};

in vec3 inPosition;
in vec2 inColor; // This is actual Lifetime + Seed

out vec4 varColor;
out vec2 varTexcoord;

const int NUM_VERTICES_PER_PARTICLE = 4;
const vec4 UNIT_QUAD[NUM_VERTICES_PER_PARTICLE] = vec4[NUM_VERTICES_PER_PARTICLE](
    vec4(-1.0, -1.0, 0.0, 1.0),
    vec4(1.0, -1.0, 0.0, 1.0),
    vec4(-1.0, 1.0, 0.0, 1.0),
    vec4(1.0, 1.0, 0.0, 1.0)
);

float bezierInterpolate(float y1, float y2, float y3, float u) {
    // https://en.wikipedia.org/wiki/Bezier_curve
    return (1.0 - u) * (1.0 - u) * y1 + 2.0 * (1.0 - u) * u * y2 + u * u * y3;
}

float interpolate3Floats(float y1, float y2, float y3, float u) {
    if ((u <= 0.5 && y1 == y2) || (u >= 0.5 && y2 == y3)) {
        // Flat line.
        return y2;
    }
    
    if ((y2 >= y1 && y2 >= y3) || (y2 <= y1 && y2 <= y3)) {
        // U or inverted-U shape.
        // Make the slope at y2 = 0, which means that the control points half way between the value points have the value y2.
        if (u <= 0.5) {
            return bezierInterpolate(y1, y2, y2, 2.0 * u);
        } else {
            return bezierInterpolate(y2, y2, y3, 2.0 * u - 1.0);
        }
        
    } else {
        // L or inverted and/or mirrored L shape.
        // Make the slope at y2 be the slope between y1 and y3, up to a maximum of double the minimum of the slopes between y1
        // and y2, and y2 and y3. Use this slope to calculate the control points half way between the value points.
        // Note: The maximum ensures that the control points and therefore the interpolated values stay between y1 and y3.
        float slope = y3 - y1;
        float slope12 = y2 - y1;
        float slope23 = y3 - y2;
        if (abs(slope) > abs(2.0 * slope12)) {
            slope = 2.0 * slope12;
        } else if (abs(slope) > abs(2.0 * slope23)) {
            slope = 2.0 * slope23;
        }
        
        if (u <= 0.5) {
            return bezierInterpolate(y1, y2 - slope / 2.0, y2, 2.0 * u);
        } else {
            return bezierInterpolate(y2, y2 + slope / 2.0, y3, 2.0 * u - 1.0);
        }

//        float uGreaterHalf = step(0.5, u);
//        float uSign = sign(uGreaterHalf - 0.5);
//        vec4 y12 = mix(y1, y2, uGreaterHalf)
//        vec4 y23 = mix(y2, y3, uGreaterHalf)
//        
//        return bezierInterpolate(y12, y2 + uSign * slope / 2.0, y23, 2.0 * u - uGreaterHalf);
    }
}

vec4 interpolate3Vec4(vec4 y1, vec4 y2, vec4 y3, float u) {
    return vec4(interpolate3Floats(y1.x, y2.x, y3.x, u),
                interpolate3Floats(y1.y, y2.y, y3.y, u),
                interpolate3Floats(y1.z, y2.z, y3.z, u),
                interpolate3Floats(y1.w, y2.w, y3.w, u));
}


void main(void) {
    TransformCamera cam = getTransformCamera();
    TransformObject obj = getTransformObject();
    
    // Which icon are we dealing with ?
    int particleID = gl_VertexID / NUM_VERTICES_PER_PARTICLE;
    // Which quad vertex pos?
    int twoTriID = gl_VertexID - particleID * NUM_VERTICES_PER_PARTICLE;
	
	// Particle properties
    float age = inColor.x / particle.lifespan;
    float seed = inColor.y;

    // Pass the texcoord and the z texcoord is representing the texture icon
    varTexcoord = vec2((UNIT_QUAD[twoTriID].xy + 1.0) * 0.5);
    varColor = interpolate3Vec4(particle.color.start, particle.color.middle, particle.color.finish, age);
    
    // anchor point in eye space
    float radius = interpolate3Floats(particle.radius.start, particle.radius.middle, particle.radius.finish , age);
    vec4 quadPos = radius * UNIT_QUAD[twoTriID];

    vec4 anchorPoint;
    <$transformModelToEyePos(cam, obj, inPosition, anchorPoint)$>
    
    vec4 eyePos = anchorPoint + quadPos;
    <$transformEyeToClipPos(cam, eyePos, gl_Position)$>
}
