<!
//  Light.slh
//  fragment shader
//
//  Created by Sam Gateau on 1/25/14.
//  Copyright 2013 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
!>
<@if not MODEL_LIGHT_SLH@>
<@def MODEL_LIGHT_SLH@>

<@include model/SphericalHarmonics.shared.slh@>
<@include model/LightVolume.shared.slh@>
<@include model/LightIrradiance.shared.slh@>

// NOw lets define Light


struct Light {
    LightVolume volume;
    LightIrradiance irradiance;
};

// Light is the light source its self, d is the light's distance calculated as length(unnormalized light vector).
float evalLightAttenuation(Light l, float d) {
    float radius = lightIrradiance_getFalloffRadius(l.irradiance);
    float cutoff = lightVolume_getRadius(l.volume);
    float denom = d / radius + 1.0;
    float attenuation = 1.0 / (denom * denom);


    // "Fade" the edges of light sources to make things look a bit more attractive.
    // Note: this tends to look a bit odd at lower exponents.
    attenuation *= min(1, max(0, -(d - cutoff)));

    return attenuation;
}


float evalLightSpotAttenuation(Light l, float cosA) {
    return pow(cosA, lightIrradiance_getFalloffSpot(l.irradiance));
}

bool light_isSpot(Light l) { return lightVolume_isSpot(l.volume); }

vec3 getLightPosition(Light l) { return lightVolume_getPosition(l.volume); }
vec3 getLightDirection(Light l) { return lightVolume_getDirection(l.volume); }


vec3 getLightColor(Light l) { return lightIrradiance_getColor(l.irradiance); }
float getLightIntensity(Light l) { return lightIrradiance_getIntensity(l.irradiance); }
vec3 getLightIrradiance(Light l) { return lightIrradiance_getIrradiance(l.irradiance); }







struct LightAmbient {
    vec4 _ambient;
    SphericalHarmonics _ambientSphere;
};

SphericalHarmonics getLightAmbientSphere(LightAmbient l) {
    return l._ambientSphere;
}


float getLightAmbientIntensity(LightAmbient l) { return l._ambient.w; }


bool getLightHasAmbientMap(LightAmbient l) {
    return l._ambient.x > 0;
  //  return l._control.x > 0;
}

float getLightAmbientMapNumMips(LightAmbient l) {
    return l._ambient.x;
}

<@func declareLightBuffer(N)@>

<@if N@>
uniform lightBuffer {
    Light lightArray[<$N$>];
};

Light getLight(int index) {
    return lightArray[index];
}

<@else@>
uniform lightBuffer {
    Light light;
};
Light getLight() {
    return light;
}

<@endif@>

<@endfunc@>






<@func declareLightAmbientBuffer(N)@>

<@if N@>

uniform lightAmbientBuffer {
    LightAmbient lightAmbientArray[<$N$>];
};

LightAmbient getLightAmbient(int index) {
    return lightAmbientArray[index];
}

<@else@>
uniform lightAmbientBuffer {
    LightAmbient lightAmbient;
};

LightAmbient getLightAmbient() {
    return lightAmbient;
}

<@endif@>

<@endfunc@>


<@endif@>
