//
//  FBXReader_Material.cpp
//  interface/src/fbx
//
//  Created by Sam Gateau on 8/27/2015.
//  Copyright 2015 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

#include <iostream>
#include <QBuffer>
#include <QDataStream>
#include <QIODevice>
#include <QStringList>
#include <QTextStream>
#include <QtDebug>
#include <QtEndian>
#include <QFileInfo>
#include "FBXReader.h"

#include <memory>

bool FBXMaterial::needTangentSpace() const {
    return !normalTexture.isNull();
}

FBXTexture FBXReader::getTexture(const QString& textureID) {
    FBXTexture texture;
    texture.filename = textureFilenames.value(textureID);
    texture.name = textureNames.value(textureID);
    texture.content = textureContent.value(texture.filename);
    texture.transform.setIdentity();
    texture.texcoordSet = 0;
    QHash<QString, TextureParam>::const_iterator it = textureParams.constFind(textureID);
    if (it != textureParams.end()) {
        const TextureParam& p = (*it);
        texture.transform.setTranslation(p.translation);
        texture.transform.setRotation(glm::quat(glm::radians(p.rotation)));
        texture.transform.setScale(p.scaling);
        if ((p.UVSet != "map1") && (p.UVSet != "UVSet0")) {
            texture.texcoordSet = 1;
        }
        texture.texcoordSetName = p.UVSet;
    }
    return texture;
}

void FBXReader::consolidateFBXMaterials() {
    
  // foreach (const QString& materialID, materials) {
    for (QHash<QString, FBXMaterial>::iterator it = _fbxMaterials.begin(); it != _fbxMaterials.end(); it++) {
        FBXMaterial& material = (*it);
        // the pure material associated with this part
        bool detectDifferentUVs = false;
        FBXTexture diffuseTexture;
        QString diffuseTextureID = diffuseTextures.value(material.materialID);
        if (!diffuseTextureID.isNull()) {
            diffuseTexture = getTexture(diffuseTextureID);
                    
            // FBX files generated by 3DSMax have an intermediate texture parent, apparently
            foreach (const QString& childTextureID, _connectionChildMap.values(diffuseTextureID)) {
                if (textureFilenames.contains(childTextureID)) {
                    diffuseTexture = getTexture(diffuseTextureID);
                }
            }

            // TODO associate this per part
            //diffuseTexture.texcoordSet = matchTextureUVSetToAttributeChannel(diffuseTexture.texcoordSetName, extracted.texcoordSetMap);

            material.diffuseTexture = diffuseTexture;

            detectDifferentUVs = (diffuseTexture.texcoordSet != 0) || (!diffuseTexture.transform.isIdentity());
        }
                
        FBXTexture normalTexture;
        QString bumpTextureID = bumpTextures.value(material.materialID);
        if (!bumpTextureID.isNull()) {
            normalTexture = getTexture(bumpTextureID);
          
            // TODO Need to generate tangent space at association per part
            //generateTangents = true;

           // TODO at per part association time
           // normalTexture.texcoordSet = matchTextureUVSetToAttributeChannel(normalTexture.texcoordSetName, extracted.texcoordSetMap);

            material.normalTexture = normalTexture;

            detectDifferentUVs |= (normalTexture.texcoordSet != 0) || (!normalTexture.transform.isIdentity());
        }
                
        FBXTexture specularTexture;
        QString specularTextureID = specularTextures.value(material.materialID);
        if (!specularTextureID.isNull()) {
            specularTexture = getTexture(specularTextureID);
           // TODO at per part association time
        //    specularTexture.texcoordSet = matchTextureUVSetToAttributeChannel(specularTexture.texcoordSetName, extracted.texcoordSetMap);
            detectDifferentUVs |= (specularTexture.texcoordSet != 0) || (!specularTexture.transform.isIdentity());
        }

        FBXTexture emissiveTexture;
        glm::vec2 emissiveParams(0.f, 1.f);
        emissiveParams.x = _lightmapOffset;
        emissiveParams.y = _lightmapLevel;

        QString emissiveTextureID = emissiveTextures.value(material.materialID);
        QString ambientTextureID = ambientTextures.value(material.materialID);
        if (_loadLightmaps && (!emissiveTextureID.isNull() || !ambientTextureID.isNull())) {

            if (!emissiveTextureID.isNull()) {
                emissiveTexture = getTexture(emissiveTextureID);
                emissiveParams.y = 4.0f;
            } else if (!ambientTextureID.isNull()) {
                emissiveTexture = getTexture(ambientTextureID);
            }

            // TODO : do this at per part association
            //emissiveTexture.texcoordSet = matchTextureUVSetToAttributeChannel(emissiveTexture.texcoordSetName, extracted.texcoordSetMap);

            material.emissiveParams = emissiveParams;
            material.emissiveTexture = emissiveTexture;


            detectDifferentUVs |= (emissiveTexture.texcoordSet != 0) || (!emissiveTexture.transform.isIdentity());
        }

        // Finally create the true material representation
        material._material = std::make_shared<model::Material>();
        material._material->setEmissive(material.emissiveColor);
        if (glm::all(glm::equal(material.diffuseColor, glm::vec3(0.0f)))) {
            material._material->setDiffuse(material.diffuseColor); 
        } else {
            material._material->setDiffuse(material.diffuseColor); 
        }
        material._material->setMetallic(glm::length(material.specularColor)); 
        material._material->setGloss(material.shininess); 

        if (material.opacity <= 0.0f) {
            material._material->setOpacity(1.0f); 
        } else {
            material._material->setOpacity(material.opacity); 
        }
    }
}

