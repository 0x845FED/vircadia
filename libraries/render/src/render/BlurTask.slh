//  Generated on <$_SCRIBE_DATE$>
//
//  Created by Sam Gateau on 6/7/16.
//  Copyright 2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@func declareBlurUniforms()@>

#define NUM_TAPS 7
#define NUM_TAPS_OFFSET 3.0f

float uniformFilterWidth = 0.05f;

const float gaussianDistributionCurve[NUM_TAPS] = float[](
    0.383f, 0.006f, 0.061f, 0.242f, 0.242f, 0.061f, 0.006f
);
const float gaussianDistributionOffset[NUM_TAPS] = float[](
    0.0f,  -3.0f,  -2.0f,  -1.0f,   1.0f,   2.0f,   3.0f
);

struct BlurParameters {
    vec4 resolutionInfo;
    vec4 filterInfo;
    vec4 depthInfo;
    vec4 stereoInfo;
};

uniform blurParamsBuffer {
    BlurParameters parameters;
};

vec2 getViewportInvWidthHeight() {
    return parameters.resolutionInfo.zw;
}

float getFilterScale() {
    return parameters.filterInfo.x;
}


float getDepthThreshold() {
    return parameters.depthInfo.x;
}

float getDepthPerspective() {
    return parameters.depthInfo.w;
}

<@endfunc@>


<@func declareBlurGaussian()@>

<$declareBlurUniforms()$>

uniform sampler2D sourceMap;

vec4 pixelShaderGaussian(vec2 texcoord, vec2 direction, vec2 pixelStep) {

    vec4 sampleCenter = texture(sourceMap, texcoord);

    vec2 finalStep = getFilterScale() * direction * pixelStep;
    vec4 srcBlurred = vec4(0.0);
    
    for(int i = 0; i < NUM_TAPS; i++) {
        // Fetch color and depth for current sample.
        vec2 sampleCoord = texcoord + (gaussianDistributionOffset[i] * finalStep);
        vec4 srcSample = texture(sourceMap, sampleCoord);
        // Accumulate.
        srcBlurred += gaussianDistributionCurve[i] * srcSample;
    }
    
    return srcBlurred;
}

<@endfunc@>

<@func declareBlurGaussianDepthAware()@>

<$declareBlurUniforms()$>

uniform sampler2D sourceMap;
uniform sampler2D depthMap;

vec4 pixelShaderGaussianDepthAware(vec2 texcoord, vec2 direction, vec2 pixelStep) {

    float sampleDepth = texture(depthMap, texcoord).x;
    vec4 sampleCenter = texture(sourceMap, texcoord);

    // Calculate the width scale.
    float distanceToProjectionWindow = getDepthPerspective();

    float depthThreshold = getDepthThreshold();

    // Calculate the final step to fetch the surrounding pixels.
    float filterScale = getFilterScale();
    float scale = distanceToProjectionWindow / sampleDepth;

    vec2 finalStep = filterScale * scale * direction * pixelStep; // *1000.0;

    // Accumulate the center sample
    vec4 srcBlurred = gaussianDistributionCurve[0] * sampleCenter;
    
    for(int i = 1; i < NUM_TAPS; i++) {
        // Fetch color and depth for current sample.
        vec2 sampleCoord = texcoord + (gaussianDistributionOffset[i] * finalStep);
        float srcDepth = texture(depthMap, sampleCoord).x;
        vec4 srcSample = texture(sourceMap, sampleCoord);

        
        // If the difference in depth is huge, we lerp color back.
        float s = clamp(/*depthThreshold */12.0 * distanceToProjectionWindow  * filterScale * abs(srcDepth - sampleDepth), 0.0, 1.0);
       // float s = clamp(depthThreshold * distanceToProjectionWindow  * filterScale * abs(srcDepth - sampleDepth), 0.0, 1.0);
        srcSample = mix(srcSample, sampleCenter, s);

        // Accumulate.
        srcBlurred += gaussianDistributionCurve[i] * srcSample;
    }
    
    return srcBlurred;
}

<@endfunc@>
