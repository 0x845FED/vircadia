// File generated by Scribe Wed Aug  5 16:50:24 2015
#ifndef scribe_simple_frag_h
#define scribe_simple_frag_h

const char simple_frag[] = R"SCRIBE(#version 410 core
//  Generated on Wed Aug  5 16:50:24 2015
//
//  simple.frag
//  fragment shader
//
//  Created by Andrzej Kapolka on 9/15/14.
//  Copyright 2014 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

layout(location = 0) out vec4 _fragColor0;
layout(location = 1) out vec4 _fragColor1;
layout(location = 2) out vec4 _fragColor2;

// the glow intensity
uniform float glowIntensity;

// the alpha threshold
uniform float alphaThreshold;

float evalOpaqueFinalAlpha(float alpha, float mapAlpha) {
    return mix(alpha * glowIntensity, 1.0 - alpha * glowIntensity, step(mapAlpha, alphaThreshold));
}

const vec3 DEFAULT_SPECULAR = vec3(0.1);
const float DEFAULT_SHININESS = 10;

void packDeferredFragment(vec3 normal, float alpha, vec3 diffuse, vec3 specular, float shininess) {
    if (alpha != glowIntensity) {
        discard;
    }
    _fragColor0 = vec4(diffuse.rgb, alpha);
    _fragColor1 = vec4(normal, 0.0) * 0.5 + vec4(0.5, 0.5, 0.5, 1.0);
    _fragColor2 = vec4(specular, shininess / 128.0);
}

void packDeferredFragmentLightmap(vec3 normal, float alpha, vec3 diffuse, vec3 specular, float shininess, vec3 emissive) {
    if (alpha != glowIntensity) {
        discard;
    }
    
    _fragColor0 = vec4(diffuse.rgb, alpha);
    //_fragColor1 = vec4(normal, 0.0) * 0.5 + vec4(0.5, 0.5, 0.5, 1.0);
    _fragColor1 = vec4(normal, 0.0) * 0.5 + vec4(0.5, 0.5, 0.5, 0.5);
    _fragColor2 = vec4(emissive, shininess / 128.0);
}

void packDeferredFragmentTranslucent(vec3 normal, float alpha, vec3 diffuse, vec3 specular, float shininess) {
    if (alpha <= alphaThreshold) {
        discard;
    }
    
    _fragColor0 = vec4(diffuse.rgb, alpha);
    //  _fragColor1 = vec4(normal, 0.0) * 0.5 + vec4(0.5, 0.5, 0.5, 1.0);
    //  _fragColor2 = vec4(specular, shininess / 128.0);
}





struct Material {
    vec4 _diffuse;
    vec4 _specular;
    vec4 _emissive;
    vec4 _spare;
};

uniform materialBuffer {
    Material _mat;
};

Material getMaterial() {
    return _mat;
}

float getMaterialOpacity(Material m) { return m._diffuse.a; }
vec3 getMaterialDiffuse(Material m) { return m._diffuse.rgb; }
vec3 getMaterialSpecular(Material m) { return m._specular.rgb; }
float getMaterialShininess(Material m) { return m._specular.a; }


// the interpolated normal
in vec3 _normal;
in vec3 _color;

void main(void) {
    Material material = getMaterial();
    packDeferredFragment(
                         normalize(_normal.xyz),
                         glowIntensity,
                         _color.rgb,
                         DEFAULT_SPECULAR, DEFAULT_SHININESS);
}

)SCRIBE";

#endif
